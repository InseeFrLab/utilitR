# Produire des rapports automatisés avec `R Markdown` {#rapports-auto}

## Tâches concernées et recommandations

L'utilisateur souhaite réaliser des rapports automatisés, reproductibles et faciles à actualiser en cas de modification des données. Il souhaite également produire de nombreux rapports en modifiant, en fonction de ses besoins, certains paramètres.

::: {.recommandation}
Il est recommandé d'utiliser `R Markdown` pour produire des rapports paramétrés. Si vous ne connaissez pas `R Markdown`, il est indispensable de lire au préalable la [fiche `R Markdown`](#R Markdown).
:::

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      fig.pos='H',
                      fig.align = "center",
                      warning=FALSE,
                      message=FALSE)
```

## Les rapports automatisés

### Introduction

Un rapport automatisé est un document qui contient du texte et des informations (graphiques, tableaux...) produites en exécutant un code, appelé code source. Un rapport automatisé peut prendre plusieurs formes :

+ une page internet (un fichier html) ;
+ un document texte (`Word`, `writer`, LaTeX) ;
+ une présentation (_slides_) ;
+ une carte.

Les rapports automatisés présentent deux grands avantages. Premièrement, ils sont reproductibles, car le code source contient toutes les instructions nécessaires à la production des informations contenues dans le rapport. Deuxièmement, ils sont faciles à actualiser en cas de modification des données.

Dans le cas de `R Markdown`, le code source est un fichier texte portant l'extension `.Rmd`. Le document final (ou *output*) est produit après une étape de compilation, en cliquant sur le bouton `knit` de `RStudio`. Le fichier `R Markdown` combine généralement des instructions de traitements des données, mais aussi du texte, des images, des cartes... Les instructions de traitement de données sont généralement rédigées en `R`, mais il est tout à fait possible d'utiliser `R Markdown` avec d'autres langages (par exemple `python`). L'utilisation de  `R Markdown` est détaillée dans la [fiche `R Markdown`](#R Markdown).

### Quelques bonnes pratiques

Cette section détaille les bonnes pratiques à adopter pour réaliser des rapports automatisés. Le principal conseil tient en une phrase : tous les réglages du rapport paramétré doivent être regroupés au début du code source.

### Remplir l'en-tête

Le code source d'un rapport automatisé commence toujours par un en-tête `YAML` qui doit contenir au minimum un titre, une date et un format de sortie. Voici un exemple d'en-tête :

~~~
---
title: "Titre du rapport"
date: '`r format(Sys.time(), "%d %B %Y")`'
output: pdf_document
author: "Anne Onyme"
description: "Une description vraiment utile"
---
~~~

L'en-tête permet de paramétrer finement le document de sortie, par exemple en choisissant le format du document, ou en ajoutant une table des matières et une bibliographie. Il existe un nombre considérable d'options, dont certaines sont spécifiques à un format de sortie (pdf, html, ...). La liste des options est détaillée sur le site de la documentation officielle de `R Markdown` et sur l’antisèche et le guide de référence de `R Markdown`, accessibles depuis RStudio via le menu `Help` puis `Cheatsheets.`

::: {.conseil}
Si vous souhaitez construire un rapport automatisé que vous utiliserez régulièrement, il est vivement conseillé de prendre le temps de définir un en-tête qui correspond précisément à ce que vous voulez produire.
:::


### Configurer le fonctionnement de `knitr`

Dans un deuxième temps, il est souhaitable de configurer le comportement par défaut de `knitr`. La [fiche `R Markdown`](#R Markdown) détaille les principales options. Dans le cas des rapports automatisés, la configuration de `knitr` doit porter au minimum sur les deux points suivants :

* la position et taille des figures ;
* l'affichage ou non des instructions `R` dans le fichier de sortie.

La méthode la plus simple pour configurer `knitr` consiste à inclure un *chunk* de configuration au début du fichier `R Markdown` (juste après l'en-tête). Ce *chunk* de configuration utilise la fonction `knitr::opts_chunk$set()` pour définir les options par défaut applicables à tous les _chunks_ du code source. La liste complète des paramètres est disponible sur https://yihui.org/knitr/options. Voici un exemple de _chunk_ de configuration.

~~~
```{r configuration, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning=FALSE,
                      message=FALSE,
                      error = TRUE,
                      fig.align = "center",
                      fig.width = '75%')
```
~~~

Dans cet exemple, il est demandé à `R Markdown` de ne pas inclure les instructions `R` dans le document de sortie (`echo = FALSE`). Les *warnings* et les messages d'informations n'apparaîtront pas non plus dans le fichier de sortie. En revanche, les erreurs apparaîtront (`error = TRUE`). Les figures sont centrées (`fig.align = "center"`) et ont une largeur de 75% de la largeur du texte (`fig.width = '75%'`).

::: {.conseil}
Une attention particulière doit être portée à l'utilisation de l'option `cache`. L'option `cache = TRUE` permet de signaler à `R Markdown` de ne pas ré-exécuter du code n'ayant pas été modifié depuis la dernière compilation. Ceci peut faire gagner beaucoup de temps, notamment pour les *chunks* d'importation de données volumineuses, mais peut conduire à des comportements non souhaités, notamment lorsque les données que vous utilisez dans votre rapport ont été actualisées. Si vous utilisez l'option `cache = TRUE`, et si aucun élément du code source n'a été modifié, alors les données ne seront pas réimportées lorsque vous recompilerez le rapport.
:::

### Charger les _packages_ et les données au début du code source

Il est recommandé d'intégrer au début de votre code source (par exemple juste après la configuration des options de `knitr`) un *chunk* qui charge les _packages_ utilisés dans le rapport, puis un *chunk* qui importe l'ensemble des données manipulées dans le rapport. L'intérêt de cette approche est qu'elle permet de voir facilement quels _packages_ et quelles données sont utilisées par votre rapport.

Dans la mesure du possible, il est préférable d'utiliser des chemins relatifs pour les fichiers (exemple : `./donnees/mesdonnees.csv`), plutôt que des chemins absolus (exemple : `D:/chemin/vers/les/donnees/mesdonnees.csv`).

A titre d'exemple, les deux *chunks* qui charge les _packages_ et les données pourraient ressembler à ceci :

~~~
```{r packages, include = FALSE}
library(doremifasolData)
library(data.table)
library(ggplot2)
```

```{r lecture_donnees_1, include = FALSE}
donnees <- fread("./donnees/mesdonnees.csv")
```
~~~

::: {.remarque}
Il peut arriver qu'il soit difficile d'accéder à des fichiers en utilisant uniquement des chemins relatifs. Une solution de repli consiste à définir le chemin absolu du dossier à _un seul endroit_ dans le code source du rapport, puis à l'utiliser de façon relative dans les fonctions d'importation. Voici un exemple :

~~~
```{r lecture_donnees_2, include = FALSE}
# Définir UNE SEULE FOIS le répertoire des données
dossier_donnees <- "D:/chemin/vers/les/donnees/"

# Charger les données avec un chemin relatif
donnees1 <- fread(paste0(dossier_donnees, "mesdonnees1.csv"))
donnees2 <- fread(paste0(dossier_donnees, "mesdonnees2.csv"))
```
~~~
:::

### Nommer les _chunks_

Il est important de donner un nom à tous les _chunks_, car cela facilite grandement la résolution des problèmes, en particulier si votre rapport est long. En effet, si la compilation du code source génère une erreur, `R Markdown` vous indiquera le nom du _chunk_ où se trouve l'erreur. Voici comment nommer un chunk :

~~~
```{r nom_du_chunk, include = FALSE}
addition <- 1 + 1
```
~~~

## La production de rapports "de masse" : les rapports paramétrés

Les rapports paramétrés sont une forme particulière de rapports automatisés. Ils présentent donc les mêmes avantages que les rapports automatisés (quasi reproductibles, simple à actualiser), mais permettent d'aller un peu plus loin en terme de fonctionnalités. Il est ainsi possible de générer différents rapports utilisant la même base d'instruction, mais en distinguant les traitements selon un ou plusieurs paramètres à fixer dans l'en-tête `YAML`.

Un court exemple est parfois mieux qu'un long discours, nous allons voir ci-dessous un modèle de rapport "générique" (un *template*), qui peut se décliner selon :

+ différents territoires ;
+ différentes périodicités ;
+ différents code d'une nomenclature...

Bref, selon différents **paramètres**.

Prenons l'exemple très simple d'un utilisateur qui doit générer une table d'effectif de chaque département français.

Pour cela, il peut être tenté de multiplier les fichiers `R Markdown` (`fichier_Ain.Rmd`, `fichier_Aisne.Rmd`...).

Cette approche, si elle se justifie lorsque le nombre de document à produire est réduit, voit ses limites lorsqu'il s'agit de réaliser plusieurs dizaines de rapports. C'est à ce moment que le système de rapports paramétrés prend tout son sens.

L'utilisateur a eu vent de la fonctionnalité de rapports paramétrés. Il doit alors réaliser un *template* de document qui s'appliquera de la même façon pour chaque département.

## Un exemple de *template*

Voici un exemple (appelons le `rapport_parametre.Rmd`) permettant de répondre au besoin de notre utilisateur :

~~~

---
title: "Mon rapport"
date: "`r Sys.Date()`"
output: pdf_document
params:
  code_dpt: "01"
---

```{r doremisfasol, eval=FALSE, echo=TRUE}
library("doremifasolData")
```

```{r import_data, eval=FALSE, echo=TRUE}
cog_com_2019 <- doremifasolData::cog_com_2019
```

```{r select_data, eval=FALSE, echo=TRUE}
mon_dpt <- cog_com_2019[cog_com_2019$dep %in% params$code_dpt, ]
```

```{r table_data, eval=FALSE, echo=TRUE}
table(mon_dpt$dep)
```
~~~

La compilation de ce fichier, au travers de la commande `rmarkdown::render(input = rapport_parametre.Rmd)` génèrera le document suivant :

~~~
 01
393
~~~

La fonction `render` permet de transformer un format de fichier (ici `rapport_parametre.Rmd`) en un autre, défini dans l'en-tête `YAML`. On remarque que la fonction produit une table d'effectif des communes de l'Ain (département 01) car cette valeur a été définie par défaut dans l'en-tête. Si l'utilisateur souhaite produire le même type de document pour un autre département, il devra **passer explicitement le paramètre `params = list(code_dpt = "XX")`** à la fonction `render`.

```{r tableDpt02, eval=FALSE, echo=TRUE}
rmarkdown::render(input = rapport_parametre.Rmd, params = list(code_dpt = "02"))
```

Dans cet exemple, l'*output* ressemblera à ceci :

~~~
 02
800
~~~

Il y a donc 800 communes dans l'Aisne.

::: {.conseil}
Il est possible de créer une fonction pour simplifier la génération de rapports paramétrés.
:::

Afin d'illuster ce conseil, voici un exemple de fonction créée *ad hoc* par l'utilisateur désireux de simplifier la production d'un rapport paramétré :

~~~
mon_rapport <- function(code_dpt) {
	rmarkdown::render(input = "rapport_parametre.Rmd",
										params = list(code_dpt = code_dpt),
										envir = new.env(),
										output_file = paste0("Rapport_", code_dpt, ".pdf")
	)
}
~~~

Une fois la fonction établie, les rapports se réaliseront *via* la commande :

~~~
mon_rapport(code_dpt = "02")
~~~

Enfin, cette fonction peut également s'utiliser dans une boucle, au sein d'un autre document `R Markdown` :

~~~
for(i in ma_liste_de_dpt) {
	mon_rapport(i)
}
~~~

Le modèle de *rapport_parametre.Rmd* présenté dans cette fiche est disponible en téléchargement en cliquant sur le lien suivant (insérer lien vers fichier).

# PESP

https://bookdown.org/yihui/R Markdown/parameterized-reports.html
