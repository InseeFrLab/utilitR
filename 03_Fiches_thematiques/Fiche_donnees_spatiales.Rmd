# Traiter des données spatiales en `R` {#spatdata}

## Tâches concernées et recommandations

L’utilisateur souhaite traiter avec `R` des données spatiales (données géolocalisées, polygones...). Si vous ne savez pas si cette fiche répond à votre besoin, les données spatiales sont définies dans le paragraphe [Définition des données spatiales].

::: recommandation
**Recommandations de l'Insee**

* **Il est recommandé d'utiliser le *package* `sf` qui couvre les principaux besoins** (lecture des formats de données géographiques, traitements des données spatiales, représentations graphiques);
* **Sauf cas particuliers, il est recommandé de ne pas utiliser le *package* `sp`, qui est rendu obsolète par `sf`**;
* Selon le besoin exact, plusieurs autres *packages* proposent des fonctionnalités complémentaires (voir section [Pour aller plus loin].)
:::

Le package `sp` est rendu obsolète par `sf`. Il est donc préférable de ne pas utiliser les morceaux de code disponibles sur internet proposant `sp`, sauf si on a besoin d'utiliser d'autres types de dépendances, notamment `spdep`. 

Selon le besoin exact, plusieurs autres *packages* proposent des fonctionnalités complémentaires :

* le *package* `raster` pour gérer le format de données de type maillage ;
* les *packages* pour l'analyse statistique spatiale :
  * `spdep` pour l'économétrie spatiale : relations de voisinage entre objets spatiaux, indices d'autocorrélation spatiale, ... ;
  * `spatstat` pour ...
  * `gstat` et `geoR` pour la géostatistique
  * `btb` pour du lissage
* le *package* `rpostgis` pour interfacer `R` à une base de données `PostGIS`.

<!--- Lino: plus besoin car `sf::st_distance` fonctionne
* `fields` pour calculer la distance entre 2 points ; ---->

Le package `sf` est une extension de `dplyr` pour les objets géographiques. On peut donc utiliser le *pipe* (`%>%`) pour chaîner des opérations. A COMPLETER AVEC UNE REFERENCE AU GUIDE DE BONNES PRATIQUES, PARTIE PIPE

Le *package* `sf` repose sur le standard ISO 19125 [*simple feature access*](https://en.wikipedia.org/wiki/Simple_Features) défini conjointement par l'*Open Geospatial Consortium (OGC)* et l'*International Organization for Standardization (ISO)*. Les systèmes de projection sont définis par des codes dits *codes EPSG*. Ce [site](https://epsg.io/) est une bonne aide mémoire. Les plus fréquents, pour les utilisateurs français, sont les suivants:

* `2154`: système de projection Lambert 93. Il s'agit du système de projection officiel: la plupart des données diffusées par l'administration pour la métropole sont accessibles à partir de ce format.
* `4326`: WGS 84 ou système de pseudo-Mercator. C'est le système de représentation utilisé par les données GPS.
* `27572`: Lambert II étendu. Il s'agit de l'ancien système de projection officiel. Les données spatiales anciennes peuvent être dans ce format.

Tableau synthèse des [SRC usités en France](https://geodesie.ign.fr/contenu/fichiers/documentation/SRCfrance.pdf) ?

|   Région    | Système				| code epsg |
|-------------|---------------|-----------|
| Métropole		| RGF93					| 2154			|
| Guadeloupe	| RGAF09				| 5490			|
| Martinique	| RGAF09				| 5490			|
| Guyane			| RGFG95				| 2972			|
| La Réunion	| RGR92					| 2975			|
| Mayotte			| RGM04					| 4471			|







Pour exécuter cette fiche, il est nécessaire d'importer le *package* `magrittr`:

```{r}
library(magrittr)
```

Il est également nécessaire d'avoir installé le package `sf` mais il n'est pas nécessaire de l'importer pour pouvoir exécuter le code ci-dessous.

## Définition des données spatiales

`R` dispose de fonctionnalités graphiques avancées qui permettent de représenter des données sous forme de cartes. `R` peut agir comme un système d'information géographique (SIG), c'est à dire un système capable de stocker, organiser et présenter des données alphanumériques spatialement référencées par des coordonnées dans un système de référence (CRS). Une base de données spatiale est, en `R`, une base de données traditionnelle (de type `dataframe`) enrichie d'une géométrie qui permet une représentation dans un espace euclidien ($(x,y)$). Cette géométrie peut prendre la forme de points, de polygones, etc. Le passage de l'espace plan à l'espace réel (la terre, qui est une sphère) se fait grâce à un système de projection. 

Pour réaliser ce type de travaux, il est nécessaire de disposer de 2 *types* de données :

1. des données géographiques : objets géométriques tels que des points, vecteurs, polygones, ... ou des maillages (*raster*) ;
2. des données attributaires : des mesures à représenter sur les cartes.

L'Insee propose un outil pour sélectionner et télécharger des données géographiques : [Créacarte](http://creacartes.insee.fr/).


## Importer des données géographiques

`sf` propose un ensemble de fonctions, la plupart préfixées par `st_`

La fonction `sf::st_read()` permet de lire différents formats de données géographiques. Les paramètres attendus par la fonction sont :

* `dsn`, le nom de la source de donnée (nom du fichier ou chemin vers le répertoire contenant les données géo) ;
* `layer`, le nom de la couche. Ce paramètre est facultatif si les données ne contiennent qu'une seule couche.

Cette fiche propose d'utiliser le jeu de données `martinique` du package `cartography` pour illustrer la manière dont on peut exploiter des données spatiales comme s'il s'agissait de données traditionnelles

```{r}
martinique <- sf::st_read(system.file("shape/martinique.shp", package="cartography"),
                  quiet=TRUE)

plot(martinique['P13_POP'])
```

Il est possible également de définir le système de projection dès l'import, via l'argument `crs`. Un objet `sf` correspond en fait à un `dataframe` avec une colonne `geometry` adoptée au type d'objet, par exemple des polygones :

```{r}
head(martinique)
```

Pour revenir à un `dataframe` traditionnel, c'est-à-dire sans la dimension géographique, la manière la plus simple est de rendre nulle la géométrie grâce à la commande `sf::st_set_geometry`:

```{r}
martinique %>% sf::st_set_geometry(NULL) %>% head()
```

## Où trouver des *shapefiles* ?

  
## Effectuer des opérations sur les données d'un objet géographique

Avec le *package* `sf`, il est possible d'appliquer les 6 verbes de la grammaire `dplyr` comme si l'objet n'était pas un objet géographique. Attention toutefois aux temps d'exécution qui sont plus lent que pour un `dataframe` traditionnel: pour des données de grande dimension, il peut être préférable d'effectuer les opérations avant de joindre une géométrie à celui-ci. 

On peut ainsi sélectionner un sous-champ de la base avec `dplyr::filter` ou faire du tri avec `dplyr::arrange`:

```{r}
martinique %>% dplyr::filter(P13_POP>10000) %>% head()
martinique %>% dplyr::arrange(P13_POP)
```

Sélectionner des colonnes avec `dplyr::select` et en créer de nouvelles avec `dplyr::mutate`:

```{r}
martinique %>% dplyr::select(P13_POP) %>% dplyr::mutate(lpop = log(P13_POP)) %>% head()
```

On peut appliquer des fonctions de statistiques descriptives avec `dplyr::summarise` et construire des groupes avec `dplyr::group_by`. Le `group_by` sur un objet spatial va également agréger les géométries: il va créer une nouvelle géométrie recoupant l'ensemble des points, des lignes ou des polygones appartenant au groupe. Par exemple, il va construire une géométrie région par somme des géométries des départements. 

Par exemple, imaginons que la base précédente recoupe 2 groupes: les villes de plus de 2000 habitants et celles de moins. On désire faire la somme de la variable `P13_POP` par groupe. Dans ce cas, après avoir créé les groupes, on va effectuer un `group_by` puis un `summarise`:

```{r}
martinique_agg <- martinique %>%
  dplyr::mutate(group = P13_POP<2000) %>%
  dplyr::group_by(group) %>%
  dplyr::summarise(P13_POP = sum(P13_POP))

head(martinique_agg)
```

Le résultat est analogue à celui qu'on obtiendrait avec un *dataframe*, à l'exception de la colonne `geometry`. On obtient une colonne de format `MULTIPOLYGON` qui agrège des polygones. La représentation graphique rend plus évidente cette agrégation (cf. fiche cartographie):

```{r}
plot(martinique['P13_POP'])
plot(martinique_agg['P13_POP'])
```


## Effectuer des opérations sur les géométries d'un objet géométrique

`sf` propose de nombreuses fonctions pour manier la dimension spatiale. On en trouve un certain nombre [ici](https://r-spatial.github.io/sf/reference/geos_unary.html) et [ici](https://r-spatial.github.io/sf/reference/geos_binary_ops.html).

Par exemple, on peut calculer la superficie d'un polygone avec `sf::st_area`. Si l'unité ne convient pas, il est possible de convertir cette superficie en $km^2$:

```{r}
martinique %>%
  dplyr::mutate(area = sf::st_area(.)) %>%
  dplyr::mutate(x = units::set_units(area, km^2)) %>%
  head()
```


## Joindre des données géographiques et attributaires

### Jointure sur des attributs


### Jointure à partir de la géométrie


## Gérer le système de projection

Le système de projection est fondamental pour que la dimension spatiale soit bien interprétée par `R`. Si un système de projection est défini, il s'affiche lorsqu'on affiche un objet dans la console à la ligne `epsg (SRID):`

```{r}
head(martinique)
```

Pour vérifier le système de projection d'une base de données, on peut utiliser `sf::st_crs`:

```{r}
sf::st_crs(martinique)
```

Les deux principales fonctions pour définir le système de projection utilisé sont:

* `sf::st_set_crs`: il s'agit de définir la manière dont les points *(x,y)* sont reliés à la surface terrestre. **Cette commande ne doit pas être utilisée pour changer de système de coordonnées**. 
* `sf::st_transform`: il s'agit de projeter les points d'une géométrie à une autre. Par exemple, si on désire produire une carte avec un fond `openstreetmaps` ou une carte dynamique `leaflet`, il est nécessaire de re-projecter les données dans le système WGS 84 (code crs 4326)

La (re)définition du système de projection se fait de la manière suivante:

```{r}
martinique <- martinique %>% sf::st_set_crs(32620)
```

Alors que la reprojection s'obtient de la manière suivante:

```{r}
martinique <- martinique %>% sf::st_transform(4326)
```



## Pour aller plus loin

## Quelques bonnes pratiques

Quelques conseils généraux sur la façon de s'y prendre.

* Faut-il préprocesser les données avant de réaliser la tâche;
* Comment minimiser les temps de calculs/la charge en RAM.


## Ressources

* la documentation des *packages*;
* les vignettes et *cheatsheets* si elles existent;
* les formations proposées par l'Insee;
* les formations/tutoriels disponibles sur internet.

Dans la mesure du possible, il faut veiller à proposer des ressources en français.
