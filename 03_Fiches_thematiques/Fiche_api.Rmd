# Travailler avec des API {#api}

<!-- ## Tâches concernées et recommandations -->

<!-- Quelques détails sur la tâche dont il s'agit -->

<!-- ::: {.recommandation data-latex=""} -->

<!-- Dire en 4-5 lignes comment il est recommandé de procéder: -->

<!-- * le ou les *package*(*s*) dont l'usage est recommandé; si on recommande plusieurs *packages*, expliquer comment choisir lequel (en fonction de la taille des données, du format...) -->
<!-- * les *packages* dont l'usage est déconseillé;  -->
<!-- * les autres points de méthode essentiels. -->

<!-- ::: -->

## Rappels des notions essentielles sur les API

### Qu'est-ce qu'une API ?

Une *Application Programming Interface* (ou **API**) est une
interface de programmation qui permet d'utiliser une application existante
pour restituer des données. Il s'agit d'une façade clairement délimitée par
laquelle un logiciel offre des services à d'autres logiciels (ou utilisateurs).
L'objectif est de fournir une porte d'accès à une fonctionnalité en
cachant les détails de la mise en oeuvre. 

Ce terme peut faire peur, mais il s'agit en fait simplement d'une façon de
restituer des données. Plutôt que d'attaquer directement des bases de données,
qui sont volumineuses et complexes, des outils ont été développés pour
faire le travail intermédiaire et restituer les données
sous forme de service grâce à une requête.

À l'Insee comme ailleurs, la connexion entre les bases de données pour
les nouveaux projets tend à se réaliser via des API, afin de limiter le
nombre de personnes ayant accès aux bases, mais aussi pour faciliter
les accès avec des services sur-mesures pour les utilisateurs.

### Mise à disposition des API

Les API peuvent utiliser une interface utilisateur.  

Les API Insee mises à disposition se trouvent dans le
[catalogue des API](https://api.insee.fr/catalogue/).
Cette interface, permet :

- de s'inscrire aux différents services ;
- de visualiser les différentes requêtes proposées par les services ;
- de lancer l'API depuis cette plateforme ;
- de documenter les API.

Cependant, l'utilisation de cette interface est utile dans une démarche
exploratoire mais trouve rapidement ses limites. 
L'utilisateur va vite se rendre compte qu'il est beaucoup plus 
pratique d'utiliser une API 
via un logiciel de traitement pour automatiser un processus
ou réaliser du chargement de masse.


Pour d'autres API, mises à disposition par la
[banque de données macroéconomiques (BDM) au format SDMX (*Statistical Data and Metadata Exchange*)],
ce point d'entrée n'existe pas. De la documentation est mise à disposition
pour permettre à l'utilisateur de comprendre l'utilisation du service.
L'utilisateur devra ensuite utiliser l'API directement
via son url par un navigateur internet ou
un logiciel adapté (`R`, `Python`, `Java`...).

::: remarque
Le format SDMX (*Statistical Data and Metadata Exchange*) est une initiative
visant à promouvoir la diffusion et les échanges de données et de
métadonnées statistiques de manière cohérente. 

TO BE COMPLETED
:::

Les API sont proposées avec plusieurs degrés de liberté pour l'utilisateur :

- soit en libre accès (l'utilisation n'est ici pas contrôlée et l'utilisateur peut utiliser le service comme bon lui semble) ;
- soit via la génération d'un compte et d'un jeton qui permet de sécuriser son utilisation et limiter le nombre de requêtes.

### Requête d'une API

Comme pour l'utilisation d'une fonction ou d'une macro SAS,
l'appel d'une API s'effectue via des paramètres. 

Chaque service se présente sous la forme d'une URL. Cette URL est à compléter
avec les différents paramètres de la requête.

Prenons l'exemple de l'API Sirene, l'URL à utiliser pour avoir des
informations sur un Siren est : 
<https://api.insee.fr/entreprises/sirene/V3/siren/{siren}>
(modifier {siren} en renseignant le numéro du siren).

Chaque service proposé par l'API aura sa propre URL avec ses propres paramètres.

Enfin, le résultat envoyé par une API est majoritairement au
format `JSON` ou `XML` (formats où les informations sont hiérarchisées de
manière emboitée).
Certains services, mais c'est plus rare, proposent parfois une information
sous forme plate (de type csv).  

Du fait de la dimension hiérarchique des formats `JSON` ou `XML`, le résultat
n'est pas toujours facile à récupérer. Certaines librairies, comme
`jsonlite` ou XXX facilitent l'extraction de champs d'une sortie d'API. 
Dans certains cas, pour faciliter les utilisations des API,
des packages ont été créés pour simplifier l'écriture d'une requête ou la 
récupération du résultat.

## Quelques packages permettant une utilisation simple des API des données Insee

Nous allons voir ici quelques packages permettant de traiter l'information d'une API facilement :

### [apinsee](https://github.com/InseeFrLab/apinsee)

Ce package est très utile pour l'utilisation des API mises à diposition sur
le catalogue des API. En effet, pour ces API, pour pouvoir effectuer une requête,
il est nécessaire de: 

1. S'authentifier grâce à une clé 
les jetons ont une durée de vie
limitée et doivent régulièrement être renouvelés.
Ce package propose de facilement générer un jeton à partir de `R`.
Ainsi il n'y a plus besoin de naviguer entre le programme et le catalogue des API.

Pour stocker un jeton temporaire, il faut utiliser le fichier `.Renviron`
d'un projet. Pour cela, le package `usethis` peut être utilisé:

```{r, eval = FALSE}
usethis::edit_r_environ("user")
```

Votre fichier `.Renviron` est ouvert ou, s'il n'existait pas,
est automatiquement 
créé (vide), enregistré et ouvert
dans `RStudio` ([lien vers fiche Personnaliser session]).
Il convient d'y ajouter deux variables d'environnement, `INSEE_APP_KEY` et 
`INSEE_APP_SECRET`. Les lignes suivantes peuvent servir de modèle, en 
remplaçant la deuxième partie de chaque ligne par la clé du compte à utiliser

~~~markdown
INSEE_APP_KEY=xxxxxxxxxxxxxxxxxx    # clef du consommateur
INSEE_APP_SECRET=yyyyyyyyyyyyyyyyyy # secret du consommateur
~~~

::: remarque
L'option `user` permet de stocker ces clés dans un fichier global, connu
de tous les projets d'un utilisateur `R`. Cela évite, d'une part, de stocker
la même information à deux endroits différents. D'autre part, cela évite
d'associer des informations personnelles à un projet, qui doit être sous contrôle
de version (voir la Fiche [Utiliser R avec RStudio](#git)) car
le fichier `.Renviron` est un fichier contenant des informations personnelles. 

Si, vous avez choisi l'option `project` lors de
l'appel à `usethis::edit_r_environ`, il faut ajouter le `.Renviron` dans
les fichiers à ne pas suivre avec `Git` grâce à la commande suivante:

```{r, eval = FALSE}
usethis::edit_git_ignore(".Renviron")
```
:::

Enfin, pour créer le token temporaire, il suffit d'exécuter :


```{r, eval = FALSE}
token <- apinsee::insee_auth()
```

Ce token peut ensuite être utilisé comme valeur du paramètre token de
la fonction `httr::config()` qui sert à contrôler les paramètres d'une requête
vers internet faite par `R`

```{r, eval = FALSE}
library(httr)
set_config(config(token = token))
```

Dès lors, vous pouvez accéder aux API de
l’Insee auxquelles votre application a souscrit.

### [insee](https://github.com/InseeFr/R-Insee-Data/)

Ce package permet de télécharger les données et leurs métadonnées
diffusées sur le service `SDMX` de la Base de données Macroéconomique
de l'Insee (BDM). Cette API étant ouverte, son accès ne demande pas
d'identification, ni de jeton. Il est uniquement nécessaire de déterminer
les données souhaitées soit via une liste `idbank`,
soit via une liste de `dataset`. 

```{r echo = FALSE, message = FALSE, warning = FALSE}
library(magrittr)
df <- data.frame("Information" = c("Liste des jeux de données",
                                   "Liste des séries"),
                 "Fonction" = c("insee::get_dataset_list()",
                                "insee::get_idbank_list()")
)
df %>% 
  knitr::kable(escape = F, position = "center", full_width = F, align="ccl") %>%
  kableExtra::column_spec(1, width = "3cm", bold = TRUE) %>%
  kableExtra::column_spec(2, width = "2cm")

```




```{r, eval = FALSE}
library(insee)

# Importer les données à partir de leur idbank ou importer un dataset à partir de leur identifiant:
table_bp <- get_insee_dataset("BALANCE-PAIEMENTS")
indicateur_001694056 <- get_insee_idbank("001694056")
```

Il est possible de rajouter des filtres à ces fonctions afin de limiter
le nombre de données importées (filtre sur la période, sur la date de mise à jour, sur les filtres).


**TO BE COMPLETED**

### [inseeLocalData](https://github.com/InseeFrLab/inseeLocalData)

Ce package permet de télécharger les données localisées à la commune,
diffusées sur <https://www.insee.fr> dans la rubrique *Chiffres détaillés*,
sous forme de cubes prédéfinis. Cette API est hébergée sur le catalogue des
API de l'Insee. Une authentification par un jeton est donc nécessaire.

Le package comporte une fonction unique qui permet d’importer les données
présentes dans l’API *Données Locales* dans une liste contenant 4 objets :
- les données statistiques ;
- les modalités de chaque variable ;
- l’information sur la zone demandée ;
- l’information sur la source et le jeu de données demandé.


Exemple d'utilisation du package pour importer le nombre
d'entreprises et d'établissements en 2017 (en géographie au 01/01/2017)
selon l'activité en 5 catégorie et une indicatrice indiquant s'il s'agit
d'une entreprise individuelle ou non pour la commune de Nantes:

```{r, eval = FALSE}
library(inseeLocalData)

croisement <- "NA5_B-ENTR_INDIVIDUELLE"
jeu_donnees <- "GEO2017REE2017"
nivgeo <- "COM"
codgeo <- "44109" #CODE GEO DE NANTES
modalite <- "all.all"

donneesAPI <- get_dataset(jeton, jeu_donnees, croisement, modalite, nivgeo, codgeo)

donnees <- donneesAPI$donnees # pour accéder aux données
liste_code <- donneesAPI$liste_code # pour accéder aux nomenclatures
info_zone <- donneesAPI$info_zone # pour accéder aux données géographiques
source <- donneesAPI$source # pour accéder à la source

```

*TO BE COMPLETED: il faudrait plus de détails*

### doremifasol

TO DO

### [OECD](https://cran.r-project.org/web/packages/OECD/index.html)

::: specificite

Ce package utilise la librarie `rsmdx` qui n'est pas compatible avec
la technologie *Direct Access*. Il ne fonctionne pas en télétravail pour les
postes nomades qui accèdent à internet par ce biais.

:::

Ce package permet de télécharger les données mises à disposition sur le 
ite de l'[OCDE](https://stats.oecd.org/index.aspx?lang=fr).
Cette API étant ouverte, son accès ne demande pas d'identification, ni de jeton.

Il est uniquement nécessaire de déterminer les données souhaitées. 

Voici quelques utilisations possibles de ce package :

```{r, eval = FALSE}
library(OECD)

# Obtenir la liste des tables présentes sur le site :
dsets <- get_datasets()

# Voir les métadonnées d'une table, via l'ouverture d'une page web (ici la table DUR_D) :
browse_metadata("DUR_D")

# Importer une table de données (ici la table DUR_D) :
data <- get_dataset("DUR_D")
```

## Exemple d'utilisation d'une API sans package

Les exemples précédents proposaient l'accès à une API par le biais d'un package.
Pour lire les données d'une API ne possédant pas de package, il faut utiliser les 2 packages `R` suivants :  

-	package `httr` pour lancer la requête ;  
-	puis package `jsonlite` pour transformer la sortie, structurée en
`JSON` en dataframe.

::: remarque

Selon la structure du JSON récupéré, la manipulation du résultat peut être
assez fastidieuse avec `R`. `Python` propose des outils plus performants pour
retravailler des JSON (package `json` notamment).
Grâce au package `reticulate`, il est aisé de faire tourner un code `Python`
dans une session `R` et récupérer le résultat dans un format de données (par
exemple dataframe) de `R`

:::

### Package httr

Le package httr permet de se connecter aux sites web et de se connecter aux API.  

Il est possible de configuer la connexion internet localement sans
modifier les variables système :  

- `set_config()` permet de configurer l'accés internet utilisée par les fonctions du package.   
- `use_proxy()` permet de déterminer le proxy à utiliser.
De nombreuses institutions utilisent passent par un intermédiaire, le proxy,
pour accéder à internet. L'adresse du proxy est à ajouter au requête car sinon
`R` ne sait pas communiquer avec internet. Il s'agit d'un paramètre à ajouter dans
les options `httr`, voir ci-dessous.

::: remarque

Le proxy peut être paramétré de la manière suivante: 

```{r, eval = FALSE}
proxy <- curl::ie_get_proxy_for_url()
httr::set_config(httr::use_proxy(proxy))
```

:::

Le package `httr` permet, lorsqu'on effectue une requête `GET`, de récupérer
le résultat sous la forme d'un texte à retravailler. 

### Accès à une API sans jeton

En général, un appel à une API via `httr` s'effectue ainsi de la manière
suivante: 

```{r, eval = FALSE}
httr::content(httr::GET(url),             # url correspond à l'url à interroger
              as="text",                  # type de la sortie renvoyée
              httr::content_type_json(),  # type de la réponse de l'url
              encoding='UTF-8')           # encodage de la réponse de l'url
```

Prenons par exemple l'API d'openfood facts, une base de données alimentaire. 
Imaginons qu'on désire récupérer l'information sur un produit. Cela s'obtient
de la manière suivante:

```{r}
url <- "https://world.openfoodfacts.org/api/v0/product/3017620425400.json"

r <- httr::content(httr::GET(url),             # url correspond à l'url à interroger
                   as="text",                  # type de la sortie renvoyée
                   httr::content_type_json(),  # type de la réponse de l'url
                   encoding='UTF-8')           # encodage de la réponse de l'url
```

Le résultat est formatté sous forme de JSON, ce qui est pratique mais peu
intelligible:

```{r}
r
```

Pour en faire une information exploitable, il est nécessaire de faire quelques
efforts. Par exemple, pour n'extraire que le libellé et le nutriscore d'un produit,
ainsi que son indice de transformation nova:

```{r}
df <- data.frame(
  lapply(c("product_name","nova_groups","nutriscore_grade"), function(x){
    jsonlite::fromJSON(r, flatten = TRUE)$product[[x]]
  })
)
colnames(df) <- c("product_name","nova_groups","nutriscore_grade")
df
```

```{python, eval = FALSE}
import requests
import pandas as pd

res = requests.get("https://world.openfoodfacts.org/api/v0/product/3017620425400.json")
results = res.json()
product = results["product"]
df = pd.json_normalize(product)
df[["product_name","nova_groups","nutriscore_grade"]]
```


### Accès à une API avec jeton

Pour les API protégées par des jetons, il faut rajouter
un paramètre d'identification :

```{r, eval = FALSE}
jeton <- "XXXXX" # création d'une variable contenant le jeton

auth_header <- httr::add_headers('Authorization'= paste('Bearer',jeton)) # création d'une variable d'authentification

res <- httr::content(httr::GET(url),
                     auth_header, # ajout de la variable d'authentification
                     as="text", 
                     httr::content_type_json(), 
                     encoding='UTF-8')
```

### Package `jsonlite`

La fonction principale à utiliser est `fromJSON`.
Cette ligne permet de convertir une résultat en format `json` en un objet `R`.

### Temporisation

Pour l'utilisation d'API avec un jeton, comme celle proposées sur le
catalogue des API de l'Insee, le nombre de requête par minute est limité
(30 pour un compte standard sur le catalogue des API).
Pour ne pas être bloqué par cette limite, il est important de temporiser
les appels successifs en introduisant une latence.
La fonction permettant cela est `Sys.sleep`. Par exemple, pour 
laisser 30 secondes d'attente, taper `Sys.sleep(30)`.


::: specificite

**Exemple d'utilisation sur l'API interne RMèS**

Une API interne sur les métadonnées de l'Insee est disponible (programme RMès).
Elle permet d'obtenir de manière simplifiée des métadonnées
(sources, concepts, liste de codes géograpjiques).
Comme cette API est stockée en interne, il n'y a pas, comme pour accéder
à celles sur internet, de proxy.

Voici un exemple de requête pour accéder aux données au niveau
division de la Naf-rev2 :

```{r, eval = FALSE}
library(dplyr)
library(stringr)
library(httr)
library(jsonlite)

# L'API est stockée en interne. Il n'y a pas de proxy pour cette API
httr::set_config(httr::use_proxy(""))

# url de la requête : ici on souhaite afficher la naf rev 2
url <- "url_de_la_requete"

# connexion à l'API pour récupérer les données en JSON
res <- httr::content(httr::GET(url),
                     as="text", httr::content_type_json(), encoding='UTF-8')

# transformation des données pour les transfomers en dataframe
res_ok <- as.data.frame(jsonlite::fromJSON(res))

# travail de la table pour obtenir le niveau division de la NAF-rev2
division <- res_ok %>% 
  filter(str_detect(uri,'division')) %>% 
  select(c('code', 'intituleFr'))
```

:::

### Exemple d'utilisation de l'[API Sirene](https://api.insee.fr/catalogue/site/themes/wso2/subthemes/insee/pages/item-info.jag?name=Sirene&version=V3&provider=insee)

Cet exemple va aller chercher les liens de succession pour un établissement :

```{r, eval = FALSE}
library(apinsee)
library(httr)
library(jsonlite)

url <- "https://api.insee.fr/entreprises/sirene/V3/siret/liensSuccession?q=siretEtablissementPredecesseur%3A39478192600016"
token <- apinsee::insee_auth()
set_config(config(token = token))
res <- content(GET(url, config(token = token)), 
               as="text", 
               content_type_json(), 
               encodin='UTF-8')

res <- fromJSON(res)
sortie <- as.data.frame(res$liensSuccession)
```

L'API Sirene permet d'effectuer des recherches multicritères. Dans ce cas, il
faut séparer les codes par `%20OR%20` (code HTML signifiant ` OR `) :

```{r, eval = FALSE}
url <- "https://api.insee.fr/entreprises/sirene/V3/siret/liensSuccession?q=siretEtablissementPredecesseur%3A39478192600016%20OR%20siretEtablissementPredecesseur%3A39488939800027"
token <- apinsee::insee_auth()
set_config(config(token = token))
res <- content(httr::GET(url, httr::config(token = token)), 
               as="text", 
               content_type_json(), 
               encodin='UTF-8')

res<-fromJSON(res)
sortie <- as.data.frame(res$liensSuccession)
```

## Références

Liste des API utiles:
TO BE COMPLETED