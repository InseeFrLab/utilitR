# Une chaîne de traitement reproductible avec `targets` {#targets}

## Tâches concernées et recommandations

L'utilisateur souhaite automatiser une chaîne de traitement complexe afin de la rendre reproductible et rapide à s'exécuter en cas de modification.

::: {.recommandation}

Le *package* `targets` permet de réaliser ce type d'automatisation.

Ce package ne sera approprié que si la chaîne de traitement
est exclusivement écrite en `R`.

:::

## Pourquoi utiliser `targets`?

Le *package* `targets` peut être particulièrement intéressant: 

* dans le cadre d'un prototype ayant vocation à devenir une chaîne de production
pérenne écrite avec `R` ;
* dans le cas d'un projet d'étude qui vise à une forte reproductibilité.

Plus précisément, utiliser `targets` pour un projet permet de :

1. Viser la __reproductibilité__
de l'ensemble des étapes de traitement,
tout en minimisant au strict nécessaire la répétition de ces étapes, parfois longues
2. Adopter des __bonnes pratiques__ de développement en `R` par l'usage
(modulariser son code,
assurer la lisibilité des étapes successives du traitement...)
3. __Représenter sous forme de *pipeline*__ les étapes de sa chaîne
de traitement et leurs dépendances à partir d'une technique de
graphiques directionnels asynchrones (appelés *DAG* pour l'acronyme anglais
dans la sphère informatique)
4. Faciliter la prise en main par une autre personne
par une __organisation standardisée des codes__
et une description complète de l'enchaînement des étapes intégrée
dans le code lui-même

::: note

Le [guide des bonnes pratiques `utilitR`](https://www.pratiques.utilitr.org/)
devrait prochainement s'enrichir d'éléments concernant la gestion de
_pipelines_ de données en `R` et en `Python`. 

Les premiers éléments du débat sont disponibles sur 
[l'issue #388](https://github.com/InseeFrLab/utilitR/issues/388)
dans le dépôt `Github` d'`utilitR`.
 
:::


## Quelles sont les tâches automatisées par `targets`?

`targets` permet de définir et d'exécuter une chaîne de traitement avec :


* Sauvegarde automatique de résultats intermédiaires, ce qu'on appelle les
_"targets"_ (cibles)
* Traçabilité de ces résultats intermédiaires par `targets`:
lors de la répétition d'une exécution de la chaîne de traitement,
ils ne sont mobilisés que si ils sont reproductibles.
* Si une fonction ou un _input_ nécessaire au calcul d'une _"target"_
est modifié, `targets` repère automatiquement les étapes à reconduire,
et seulement celles-ci. 

Ainsi, le lancement du traitement et la vérification de la reproductibilité
sont effectués ensemble au cours du développement du
projet par l'appel de `tar_make()`.

__Vérifier la reproductibilité ne revient ainsi pas à 'tout relancer' de 0__ !
Ceci représenterait un coût trop élevé.
`targets` automatise le travail d'aller-retour dans les étapes d'une étude ou
de prototypage
(j'ai modifié l'étape 1, il faut donc que je relance l'étape 2 qui en dépend...),
en construisant un graphe des dépendances des différentes étapes du traitement.  


Pour la suite de la fiche,
prenons l'exemple d'une étude qui se structurerait suivant les étapes suivantes :

  0. Charger les données
  1. Traiter les données
  2. Produire des résultats
  3. Représenter des résultats


## Un projet minimal pour comprendre l'essentiel


Un projet `targets` est un projet `R` avec une structure canonique. Ce projet
contient les principaux éléments suivants :

* `_targets.R` pour décrire les éléments de configuration (par exemple
_packages_ utilisés) et l'enchaînement des traitements. 
* Un dossier `R` comprenant les scripts définissant les fonctions utilisées par le projet
* Un dossier `data` pour les données externes (non générées au cours du projet)

La structure du projet doit ainsi être comme suit:

    ├── _targets.R
    ├── R/
    ├───── mesfonctions_pour_faire_ceci.R
    ├───── mesfonctions_pour_faire_cela.R
    ├──── ...
    ├── data/
    └───── donnes_entrees.csv
    └───── ...

Organiser ses fichiers de cette façon est très commun,
mais pas indispensable pour l'utilisation de `targets`.
La seule obligation est que le fichier `_targets.R`
soit positionné dans le répertoire de travail.

Une manière commode pour un utilisateur souhaitant tester `targets`  est donc de créer un [projet RStudio](rproject.html) à la racine duquel il place ce fichier.
En prévision des futures fonctions qu'il va écrire, il crée un dossier `/R`. Le fichier `_targets.R` détaille l'enchaînement des traitements.
Il doit toujours contenir une instruction chargeant le *package* `targets`.

```{r, eval=FALSE}
# _targets.R file

library(targets)

source("R/mesfonctions_pour_faire_ceci.R")
source("R/mesfonctions_pour_faire_cela.R")

tar_option_set(packages = c("data.table","xtable"))

list(
  tar_target(
    data_file,
    "data/donnes_entrees.csv",
    format = "file"
  ),
  tar_target(
    data,
    read.csv(data_file)
  ),
  tar_target(
    data_clean,
    ma_fonction_de_nettoyage(data)
  ),
  tar_target(
    regression,
    lm(Y ~ X, data=data_clean)
  ),
  tar_target(
    table,
    ma_fonction_de_presentation_des_resultats(regression)
  )
)
```

Les fonctions écrites par l'analyste et utilisées dans la chaîne de traitement, en l'occurrence `ma_fonction_de_nettoyage` et `ma_fonction_de_presentation` sont contenues dans les fichiers que l'on "source" au départ, ici `"R/mesfonctions_pour_faire_ceci.R` et `R/mesfonctions_pour_faire_cela.R`. 

Les packages dont dépendent les analyses sont spécifiés via la fonction `tar_option_set` du *package* `targets`. 

La chaîne de traitement est représentée par une liste de `tar_target`, soit les objets R qui sont les cibles intermédiaires de l'analyse. Ils sont le résultat de l'application à une cible précédente d'une fonction pour obtenir la cible suivante. Ici la première cible est particulière (`format = file`) : on spécifie où sont les données d'entrée afin de surveiller si elles changent.  La seconde prend en entrée la première cible `data_file` et la transforme en appliquant la fonction `read.csv` en un nouvel objet R, `data`. La troisième applique cette fois une fonction écrite par l'utilisateur à `data` pour obtenir `data_clean`, et ainsi de suite. Ainsi, le fichier `_targets.R` contient la description de l'ensemble des étapes du traitements. La complexité des traitements est résumé de façon concise par un ensemble minimal de fonction résumant les grandes étapes.


Afin de faire tourner l'analyse, l'utilisateur fait appel au sein du projet à la fonction `tar_make()`. L'utilisateur est informé de l'évolution des calculs.

```{r, eval=FALSE}
tar_make()
```

```
#> • start target data_file
#> • built target data_file
#> • start target data
#> • built target data
#> • start target data_clean
#> • built target data_clean
#> • start target regression
#> • built target regression
#> • start target table
#> • built target table
#> • end pipeline

```

L'utilisateur décide ensuite de modifier la fonction `ma_fonction_de_nettoyage`. Il n'a pas besoin par la suite de déterminer quels sont les codes à refaire tourner, il refait appel à :


```{r, eval=FALSE}
tar_make()
```
```
#> ✔ skip target data_file
#> ✔ skip target data
#> • start target data_clean
#> • built target data_clean
#> • start target regression
#> • built target regression
#> • start target table
#> • built target table
#> • end pipeline
```

La modification de la fonction `ma_fonction_de_nettoyage` entraîne la nécessaire mise à jour de `data_clean` et toutes les cibles qui en dépendent, mais pas du début de la chaîne de traitement !


Les cibles définies sont calculées successivement, stockées et mises à jour automatiquement dans un dossier `_targets/objects/`. On peut facilement accéder à un objet cible ensuite à l'aide de la fonction `tar_read()` dans la console R, par exemple `tar_read(data_clean)` renvoie l'objet `data_clean` dans la dernière version construite par `tar_make()`.

A partir de cette spécification de la chaîne, `targets` construit un graphe de dépendance, qui peut être visualisé avec `tar_visnetwork()`, et décrit avec `tar_manifest()`.

Et voilà, c'est tout pour l'essentiel. La suite décrit des fonctions de targets qui aide à complexifier la chaîne de traitement. 

## Les branches

Souvent, les cibles d'une analyse (étapes intermédiaires) sont nombreuses et ont un certain degré de redondance. 

Comment créer des cibles automatiquement (sans écrire explicitement dans `_targets.R` chacune d'entre elles)? `targets` propose de décliner les cibles en "branches".

On distingue les branches définies dynamiquement (avant l'exécution, le nombre de branches est inconnu), et statiquement (le nombre de branche est définie précisément avant l'exécution). Le premier cas correspond à la répétition d'un grand nombre de tâches homogènes, le second plutôt à un petit nombre de tâches hétérogènes. Les branches statiques, qui nécessitent l'usage du package `tarchetypes`, ne sont pas abordées ici. 

### Les branches dynamiques

Certaines cibles peuvent être le résultat de l'application d'une même fonction à des variantes d'arguments (par exemple, un graphique de restitution pour plusieurs populations d'intérêt).  Pour cela, `targets` propose les _branches dynamiques_. 

### Un exemple

Voici un exemple minimal de pipeline qui va itérer sur N couples d'arguments une même "simulation", en évitant de créer N cibles distinctes pour les N résultats, et plutôt créer une seule cible résultats qui donnera lieu à autant de branches que de "simulations": 


```{r, eval=FALSE}
#_targets.R
library(targets)

simulation <- function(x,y){
  x*y
}
  
list(
  tar_target(x, c(10,20,30)),
  tar_target(y, c(1,2,3)),
  tar_target(
    resultat,
    data.frame(argument_1 = x, argument_2 = y, res = simulation(x,y)),
    pattern = map(x,y))
  )
```


Ce qui distingue ici la cible `resultat`  de ce qui a été vu précédemment, c'est l'utilisation de l'argument `pattern`, qui a vocation à itérer sur les vecteurs cibles x et y grâce à `map`.

Dans la console R, l'utilisateur qui fait appel à `tar_make()` voit apparaître la déclinaison de `resultat` en trois branches, exécutées en parallèle.


```{r, eval=FALSE}
tar_make()
```
```
● run target x
● run target y
● run branch resultat_1851c9ee
● run branch resultat_445bc859
● run branch resultat_1a0263ff
● end pipeline
```
On obtient le résultat suivant:
```{r, eval=FALSE}
tar_read(resultat)
```
```
argument_1 argument_2 res
1         10          1  10
2         20          2  40
3         30          3  90
```


### Itérer, croiser les arguments pour créer des branches

Les patterns peuvent être de plusieurs types : `map` (itérer sur les arguments ligne à ligne), `cross` (produit cartésien des arguments), `head` (pour récupérer les premiers arguments), `select` (pour récupérer certains arguments) ... Par exemple, remplacer `map` par `cross` dans la pipeline précédente donne lieu après un `tar_make()` à 


```
✓ skip target x
✓ skip target y
✓ skip branch resultat_1851c9ee
● run branch resultat_cca1045b
● run branch resultat_3b73d14e
● run branch resultat_fe2f6b6a
✓ skip branch resultat_66951ce8
● run branch resultat_ff612dde
● run branch resultat_d0a65303
● run branch resultat_0a18e8b1
✓ skip branch resultat_7fd56d9a
● end pipeline
```

Plutôt que d'appliquer la fonction simulation itérativement aux couples d' x et y (3 branches), la fonction est appliquée au produit cartésien de x et y (3 x 3 branches). On remarque d'ailleurs que `targets` a compris que cela ne changeait pas certains résultats précédents (3 branches strictement identiques, qui ne sont pas recalculées).

```{r, eval=FALSE}
tar_read(resultat)
```
```
 argument_1 argument_2 res
1         10          1  10
2         10          2  20
3         10          3  30
4         20          1  20
5         20          2  40
6         20          3  60
7         30          1  30
8         30          2  60
9         30          3  90
```

Les pattern peuvent être combinés, avec par exemple `pattern = cross(x,map(y,z))`.

```{r, eval=FALSE}
#_targets.R
library(targets)

simulation <- function(x,y,z){
  x*y + z
}

list(
  tar_target(x, c(10,20,30)),
  tar_target(y, c(1,2,3)),
  tar_target(z, c(2,4,6)),
  tar_target(
    resultat,
    data.frame(argument_1 = x, argument_2 = y, argument_3 = z, res = simulation(x,y,z)),
    pattern = cross(x,map(y,z)))
)
```
qui donne le résultat :
```

  argument_1 argument_2 argument_3 res
1         10          1          2  12
2         10          2          4  24
3         10          3          6  36
4         20          1          2  22
5         20          2          4  44
6         20          3          6  66
7         30          1          2  32
8         30          2          4  64
9         30          3          6  96

```

Si l'on souhaite itérer sur des listes, plutôt que sur des vecteurs, on peut spécifier à la création de la cible qui sert d'argument aux branches, par exemple une liste de data.frames, que l'on veut itérer sur les éléments "list".

```{r, eval=FALSE}
#_targets.R
library(targets)

#' Multiplie la colonne "a" de df par un facteur
#' @param: df: data.frame
#' @param: factor: int
multiply <- function(df, factor){
  df$a <- df$a*factor
  df
}

list(
  tar_target(x, list(data.frame(name = c('Marie','Marwan'), a = c(1,2)),
                     data.frame(name = c('Bill','Boule'), a = c(2,4))), iteration = 'list'),
  tar_target(y, c(2,3)),
  tar_target(
    resultat,
    multiply(x,y),
    pattern = map(x,y))
)
```

Etc...

## Intégrer un rapport en Rmarkdown

Le *package* `tarchetypes` est un complément utile. Ce *package* permet d'intégrer simplement des rapports Rmarkdown dans la pipeline avec `tarchetypes::tar_render()`. L'essentiel des calculs doit être en amont du rapport markdown, qui doit être rapide à exécuter. 

Par exemple, on peut écrire un Rmarkdown `report.Rmd` considéré comme une des cibles de l'analyse (par exemple, c'est le compte-rendu de l'analyse), et qui dépend d'autres cibles. On souhaite également qu'il soit reproductible, et mis à jour automatiquement en fonction des modifications sur les cibles dont il dépend. Il suffit d'intégrer ces cibles via `tar_read(data)` ou `tar_load(data)` appelé dans un chunk du .Rmd, et de spécifier un `_targets.R` sur le modèle suivant:


```{r, eval=FALSE}
# _targets.R file
# report.Rmd est présent dans le projet.
library(targets)
library(tarchetypes)

list(
  tar_target(data, data.frame(a = seq(2,9), b = seq(2,9))),
  tar_render(report, path = 'report.Rmd')
)

```


## Source

Landau, W. M., (2021). The targets R package: a dynamic Make-like function-oriented pipeline toolkit for reproducibility and high-performance computing. Journal of Open Source Software, 6(57), 2959, https://doi.org/10.21105/joss.02959 

## Pour en savoir plus

* [Manuel d'utilisation de `targets`](https://books.ropensci.org/targets/)
* [_High Performance Computing avec `targets`_](https://books.ropensci.org/targets/hpc.html)
* https://cran.r-project.org/web/packages/targets/targets.pdf 
* https://docs.ropensci.org/tarchetypes/ 
* Un exemple https://github.com/InseeFrLab/lockdown-maps-R/ 
* Les "target factories": https://wlandau.github.io/targetopia/contributing.html 
