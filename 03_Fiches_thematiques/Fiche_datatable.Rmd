# Manipuler des données avec `data.table`

Cette fiche vise à présenter le package `data.table` qui offre une alternative au `tidyverse` pour manier des données. C'est une solution plus adaptée pour des bases de données de plus de 1Go que `dplyr` mais il s'agit d'un package qui peut aussi être utilisé sur des données plus petites. Un cours plus complet peut être trouvé [ici](https://gitlab.com/linogaliana/bigr/-/blob/master/04-datatable.Rmd) <!----lien temporaire en attendant la formation déployée ----> et les vignettes sont disponibles [sur ce lien](https://github.com/Rdatatable/data.table/wiki/Getting-started).


## Présentation de `data.table`

### Principe

Le package `data.table` propose une version améliorée du `data.frame` de base: le `data.table`. La visualisation est améliorée par rapport à un `data.frame` standard:

```{r}
dt <- data.table::data.table(x = runif(1e4), y = runif(1e3))
dt
```

Pour importer des données en format `data.table`, on utilisera la fonction `data.table::fread`. On peut aussi convertir un objet en `data.table` en utilisant `data.table::setDT` ou `data.table::as.data.table()`. 

Dans un `data.frame` de base, on peut utiliser les crochets `df[...]` uniquement pour sélectionner des lignes ou des colonnes. Dans un `data.table`, on peut faire beaucoup plus de choses avec les crochets `dt[...]`. En fait, les instructions à l'intérieur des crochets peuvent être conçues comme des requêtes `SQL` mises en forme différemment. 

La forme générale est la suivante:
```{r eval = F}
DT[i, j, by]

##   R:                 i                 j        by
## SQL:  where | order by   select | update  group by

```

A l'intérieur du i, on n'a pas besoin d'utiliser le préfixe `DT$` pour se référer aux variables. Cela est assez pratique, entre autres pour la lisibilité du code. Par exemple, pour effectuer une filtre et une moyenne par groupe sur les données d'exemple ci-dessous,

```{r}
# DATAFRAME D'EXEMPLE
dt <- data.table::data.table(x = exp(rnorm(1000L)),
                             y = rnorm(1000L),
                             z = sample(seq_len(3L), size = 1000L,
                                        replace = TRUE))
dt
```

en `dplyr` on va exécuter la commande suivante:

```{r}
dt %>%
  dplyr::filter(x > 3) %>%
  dplyr::group_by(z) %>%
  dplyr::summarise(sum(y))
```

alors qu'en `data.table`, la requête équivalente s'écrit:

```{r}
dt[x > 3, sum(y), by = z]
```

Les 5 verbes du `tidyverse` ont une traduction en `data.table`, plus adaptée pour ces objets. 

### Quelles fonctions peut-on utiliser avec un `data.table`?

Les `data.table` héritant de caractéristiques des `data.frames`, on peut normalement leur appliquer toutes les méthodes qui s'appliquent aux `data.frames` de base. En particulier, on peut appliquer les fonctions de maniement des données du `tidyverse` aux `data.tables`: on peut utiliser `stringr` pour le maniement de caractères, `lubridate` pour des colonnes temporelles, etc. Avant d'appliquer une fonction du `tidyverse` à un `data.table`, il est néanmoins utile de vérifier qu'il n'existe pas un équivalent déjà proposé par le package `data.table`. Par exemple, plutôt que d'utiliser la fonction `stringr::str_split_fixed()` pour séparer une colonne en fonction d'un caractère, on utilisera `data.table::tstrsplit()`

## Quelques opérations de base sur les tables de données

### Tri

```{r}
table <- data.table::as.data.table(iris)
```

Pour trier une table, on utilisera donc
```{r}
table[order(Sepal.Length,-Sepal.Width)]
```

On trie dans l'ordre croissant de `Sepal.Length` et dans l'ordre décroissant de la variable `Sepal.Width`.

### Sélection de colonnes

Pour sélectionner les colonnes d'un `data.table` et renvoyer un `data.table`, il existe plusieurs méthodes. La première consiste à indiquer sous forme de liste les colonnes à choisir:

```{r}
table[,list(Petal.Width, Species)]
table[,.(Petal.Width, Species)]
```

La notation `.()` est un alias pour `list()` qui est assez pratique en `data.table`. 

La deuxième méthode consiste à utiliser un mot clé de `data.table`, `.SD` qui signifie `Subset of Data`: 

```{r}
table[,.SD,.SDcols = c("Petal.Width", "Species")]
```

On indique les colonnes qui seront aliasées par `.SD` avec la dimension `.SDcols`. 

### Opérations sur les colonnes

Pour calculer en j sur un `data.table`, par exemple le nombre de lignes pour lesquelles une condition est vraie:
```{r}
ans <- table[,sum(Sepal.Length>0)]
ans # ou plus simplement
table[,sum(Sepal.Length>0)]
```

Calculer une moyenne pour un groupe particulier:
```{r}
ans <- table[Species == "setosa",.(moyenne = mean(Sepal.Length))]
ans
```

Premièrement, on subset en i (pour `Species == "setosa"`), ensuite on sélectionne en j et on calcule en j en même temps. 

### Le symbole `.N` 

Cela permet de calculer le nombre d'observations dans le groupes défini en i.
```{r}
ans <- table[Species == "setosa",.N]
ans
```

## Opérations par groupe

Toutes les opérations précédentes pouvaient être croisées avec une ou plusieurs variables de groupe. C'est l'équivalent du `dplyr::group_by`.  Par exemple pour compter le nombre de lignes par groupe

```{r}
ans <- table[,.N,by = "Species"]
ans 
```

<!---On peut, en utilisant de manière conjointe `lapply` et `.SD` effectuer des opérations vraiment poussées, éventuellement par groupe--->


## L'opérateur `:=`

Jusqu'à présent, nous n'avons pas créé de nouvelles colonnes à un `data.table` existant. La spécificité du `data.table` par rapport au `tibble` ou à un `data.frame` traditionnel est qu'il ne **faut pas réassigner l'objet lorsqu'on modifie une de ses colonnes*. `data.table` repose sur le passage par référence qui permet d'actualiser une colonne sans créer de copie (pour plus de détail, vous pouvez consulter [ce lien](https://gitlab.com/linogaliana/bigr/-/blob/master/04-datatable.Rmd)). C'est le rôle de l'opérateur `:=` qui actualise par référence le `data.table`. On peut considérer l'opérateur `:=` comme traduction du `dplyr::mutate` dans la grammaire `data.table` mais dont le comportement diffère (`:=` est beaucoup plus efficient). Par exemple, pour créer une nouvelle colonne, on adopte la syntaxe suivante:

```{r}
table
table[, "nouvelle_colonne" := Petal.Width*10]
table
``` 

Le `data.table` est ainsi modifié par référence, sans avoir besoin d'être réassigné avec le symbole `<-`. C'est ce comportement qui permet à `data.table` d'être très rapide et très peu gourmand en RAM, rendant son usage approprié pour des données de taille importante. 

Pour supprimer une colonne, on fait

```{r}
table[,'nouvelle_colonne' := NULL]
```


Pour créer les variables colA, colB et leur assigner les valeurs valA et valB:
```{r eval = F}
table[, c("colA", "colB") := list(Sepal.Length*5, Sepal.Width*5)]
# syntaxe qui produit le même résultat mais est plus préférable
table[, `:=`("colA" = get('Sepal.Length')*5, 
          "colB" = get('Sepal.Width')*5)]
```

Attention, lorsque l'on crée plusieurs variables ainsi, elles se créent en même temps. Si on crée des variables qui dépendent d'autres variables créées, il faut séparer l'opération en deux. 

L'opérateur `:=` peut être utilisé pour actualiser certaines lignes seulement, en fonction d'une condition logique. C'est beaucoup plus efficient qu'un terme `dplyr::if_else` ou `dplyr::case_when`. Imaginons qu'on désire créer une colonne x qui vale `Petal.Length` sauf pour les lignes où `Species` est `setosa` où elle vaut `NA`. Dans ce cas, le code `dplyr` serait:

```{r}
table %>% dplyr::mutate(x = dplyr::case_when(
    Species ~ "setosa" == NA_real_,
    TRUE ~ Petal.Length
))
```

et le code équivalent en `data.table`, nécessitant beaucoup moins de RAM:

```{r}
table[, "x" := Petal.Length]
table[Species == "setosa", x := NA_real_]
```

## .SD et lapply

## Fonctions modifiant un `data.table`

Il est très facile de créer des fonctions génériques modifiant un `data.table`
vs difficle en dplyr

