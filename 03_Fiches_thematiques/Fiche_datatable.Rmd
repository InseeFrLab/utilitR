# Manipuler des données avec `data.table`

## Tâches concernées et recommandations

L'utilisateur souhaite manipuler des données stucturées sous forme de `data.frame` (sélectionner des variables, sélectionner des observations, créer des variables, joindre des tables).

::: {.recommandation data-latex=""}
**Recommandations de l'Insee**

* Pour des tables de données de taille petite et moyenne (inférieure à 2 Go ou un million d'observations), il est recommandé d'utiliser le package `dplyr`;
* Pour des tables de données de grande taille (plus de 2 Go ou plus un million d'observations), il est recommandé d'utiliser le package `data.table` qui fait l'objet d'une autre fiche. REFERENCE A COMPLETER A TERME.
:::

::: {.conseil data-latex=""}
**Remarque**

L'utilisation du *package* `data.table` est nettement plus complexe et déroutante pour les débutants que l'utilisation de `dplyr`. Toutefois, l'apprentissage de `data.table` est particulièrement recommandé si vous avez l'intention d'utiliser `R` fréquemment avec des données volumineuses car `data.table` _beaucoup_ plus rapide et puissant que `dplyr`.
:::

Cette fiche vise à présenter le package `data.table` qui offre une alternative au `tidyverse` pour manier des données. C'est une solution plus adaptée pour des bases de données de plus de 1Go que `dplyr` mais il s'agit d'un package qui peut aussi être utilisé sur des données plus petites. Un cours plus complet peut être trouvé [ici](https://gitlab.com/linogaliana/bigr/-/blob/master/04-datatable.Rmd) <!----lien temporaire en attendant la formation déployée ----> et les vignettes sont disponibles [sur ce lien](https://github.com/Rdatatable/data.table/wiki/Getting-started).


## Présentation de `data.table`

### Principe

Le *package* `data.table` propose une version améliorée du `data.frame` de base: le `data.table`. La visualisation est améliorée par rapport à un `data.frame` standard:

```{r}
dt <- data.table::data.table(x = exp(rnorm(1e4)),
                             y = runif(1e4),
                             z = sample(1:4, 1e4, replace = TRUE))
dt
```

**La fonction fondamentale de `data.table` est la fonction `[...]` (crochets).** Dans un `data.frame` de base, les crochets `df[...]` servent uniquement à sélectionner des lignes ou des colonnes. Dans un `data.table`, les crochets `dt[...]` permettent de faire beaucoup plus de choses (quasiment tout, en pratique). En fait, les instructions à l'intérieur des crochets peuvent être envisagées comme des requêtes `SQL` mises en forme différemment. 

**La forme générale de la fonction `[...]` est la suivante: `DT[i, j, by]`**. Si on fait un parallèle avec `SQL`, `i` correspond au `WHERE`, `j` au `SELECT` et `by` au `GROUP BY`. Cet appel de fonction peut se lire comme ceci: "on part du `data.table` `DT`, on sélectionne certaines lignes avec `i`, puis on calcule `j` pour chaque groupe défini par `by`. La fonction `[...]` présente deux grands avantages:

- Il n'est pas nécessaire d'utiliser le préfixe `DT$` pour se référer aux variables à l'intérieur de `[...]`;
- Le code est très concis, ce qui aide à le rendre lisible.

Voici un exemple simple. A partir des données générées ci-dessus, on veut calculer la moyenne de `y` par groupe défini par `z`, uniquement sur les observations pour lesquelles `x` est supérieur à 3. Voici comment on peut réaliser cette opération avec `Base R`, `dplyr` et `data.table`. Vous pouvez juger vous-même de la concision du code.

```{r, echo = FALSE}
dt <- dt[order(z)]
```

<!-- Lino: il faudrait mettre un filtre ici: le code ci-dessous, c'est pour le html, et plus bas pour le LaTeX -->

<table class='table'>
<tr> <th>`Base R`</th> <th>`dplyr`</th> <th>`data.table`</th> <tr>
<tr>
<td>
```{r, eval = FALSE}
aggregate(
dt[dt[["x"]] > 3]$y,
by = list(dt[dt[["x"]] > 3]$z),
FUN = sum)
```
</td>
<td>
```{r, eval = FALSE}
dt %>%
dplyr::filter(x > 3) %>%
dplyr::group_by(z) %>%
dplyr::summarise(sum(y))
```
</td>
<td>
```{r, eval = FALSE}
dt[x > 3, sum(y), by = z]
```
</td>
<tr>
</table>

<!-- Lino: jusqu'ici c'est pour le html, et ci-dessous pour le LaTeX -->

**`Base R`**
```{r, eval = FALSE}
aggregate(dt[dt[["x"]] > 3]$y,           
          by = list(dt[dt[["x"]] > 3]$z),
          FUN = sum)
```

**`dplyr`**
```{r, eval = FALSE}
dt %>%
  dplyr::filter(x > 3) %>%
  dplyr::group_by(z) %>%
  dplyr::summarise(sum(y))
```

**`data.table`**
```{r, eval = FALSE}
dt[x > 3, sum(y), by = z]
```

<!-- Lino: fin du code pour le LaTeX -->

### Comment mettre des données dans un `data.table`?

Il y a principalement deux méthodes pour mettre des données sous forme d'un `data.table`:

- la fonction `data.table::fread()` importe un fichier plat comme les `.csv` (voir la fiche [Importer des fichiers plats (`.csv`, `.tsv`, `.txt`)]);
- Les fonctions `data.table::setDT()` et `data.table::as.data.table()` convertissent un `data.frame` en `data.table`.

### Quelles fonctions peut-on utiliser avec un `data.table`?

**Les `data.tables` sont simplement des `data.frames` particuliers, donc on peut normalement leur appliquer toutes les méthodes valables pour les `data.frames`.** En particulier, on peut utiliser avec `data.table` toutes les fonctions des *packages* habituellement associés à `dplyr`: `stringr` pour le maniement de chaînes de caractères, `lubridate` pour les colonnes temporelles, `forcats` pour les colonnes de type `factor`, etc. Toutefois, il est utile de vérifier que le *package* `data.table` ne propose pas déjà une fonction adaptée. Par exemple, plutôt que d'utiliser la fonction `stringr::str_split_fixed()` pour séparer une colonne en fonction d'un caractère, on utilisera `data.table::tstrsplit()`.

## Quelques opérations de base avec `data.table`

On va illustrer les opérations de base en `data.table` avec le jeu de données `iris`, qu'on transforme en `data.table` pour l'occasion.

```{r}
iris_dt <- data.table::as.data.table(iris)
```

### Trier une table

**On peut trier un `data.table` avec la fonction `order()`.** On trie `iris_dt` dans l'ordre croissant de `Sepal.Length` et dans l'ordre décroissant de la variable `Sepal.Width`.

```{r}
iris_dt[order(Sepal.Length, -Sepal.Width)]
```

### Sélectionner des lignes

**On peut sélectionner des lignes dans un `data.table` avec `dt[i]`.** Exemple: on séléctionne les lignes de `iris_dt` correspondant à l'espèce "Setosa":
```{r}
selection <- iris_dt[Species == "setosa"]
```

::: {.remarque data-latex=""}
**Remarque très importante**

**Lorsqu'on souhaite conserver toutes les lignes d'un `data.table`, il faut laisser vide l'emplacement pour `i`, sans oublier la virgule.** Par exemple, pour connaître le nombre de lignes de `iris_dt`, on écrit: `iris_dt[ , .N]`.  Notez bien l'emplacement vide et la virgule après `[`.
:::


### Sélectionner des colonnes

**On peut sélectionner des colonnes dans un `data.table` et renvoyer un `data.table` de plusieurs façons**. 

- La première consiste à indiquer les colonnes à conserver sous forme de liste. La notation `.()` est un alias pour `list()` qui est assez pratique en `data.table`. 

  ```{r, eval = FALSE}
  iris_dt[ , list(Petal.Width, Species)]
  iris_dt[ , .(Petal.Width, Species)]
  ```

- La seconde méthode consiste à utiliser un mot-clé de `data.table`, `.SD` qui signifie `Subset of Data`. On indique les colonnes qui seront aliasées par `.SD` avec la dimension `.SDcols`. 

  ```{r, eval = FALSE}
  iris_dt[ , .SD, .SDcols = c("Petal.Width", "Species")]
  ```

::: {.remarque data-latex=""}
**Remarque**

La seconde méthode peut vous sembler inutilement complexe. C'est vrai dans l'exemple donné ci-dessus, mais les fonctions `.SD` et de `.SDcols` s'avèrent très puissantes dans un grand nombre de situation (notamment quand on veut programmer des fonctions qui font appel à `data.table`).
:::


### Manipuler des colonnes

Pour calculer en `j` sur un `data.table`, par exemple le nombre de lignes pour lesquelles une condition est vraie:
```{r}
ans <- iris_dt[ , sum(Sepal.Length > 0)]
ans # ou plus simplement
iris_dt[ , sum(Sepal.Length > 0)]
```

Calculer une moyenne pour un groupe particulier:
```{r}
ans <- iris_dt[Species == "setosa", .(moyenne = mean(Sepal.Length))]
ans
```

Premièrement, on subset en i (pour `Species == "setosa"`), ensuite on sélectionne en j et on calcule en j en même temps. 

### Le symbole `.N` 

Cela permet de calculer le nombre d'observations dans le groupes défini en i.
```{r}
ans <- iris_dt[Species == "setosa", .N]
ans
```

## Opérations par groupe

Toutes les opérations précédentes pouvaient être croisées avec une ou plusieurs variables de groupe. C'est l'équivalent du `dplyr::group_by`.  Par exemple pour compter le nombre de lignes par groupe

```{r}
ans <- iris_dt[ , .N, by = "Species"]
ans 
```

<!---On peut, en utilisant de manière conjointe `lapply` et `.SD` effectuer des opérations vraiment poussées, éventuellement par groupe--->


## L'opérateur `:=`

Jusqu'à présent, nous n'avons pas créé de nouvelles colonnes à un `data.table` existant. La spécificité du `data.table` par rapport au `tibble` ou à un `data.frame` traditionnel est qu'il ne **faut pas réassigner l'objet lorsqu'on modifie une de ses colonnes**. `data.table` repose sur le passage par référence qui permet d'actualiser une colonne sans créer de copie (pour plus de détail, vous pouvez consulter [ce lien](https://gitlab.com/linogaliana/bigr/-/blob/master/04-datatable.Rmd)). C'est le rôle de l'opérateur `:=` qui actualise par référence le `data.table`. On peut considérer l'opérateur `:=` comme traduction du `dplyr::mutate` dans la grammaire `data.table` mais dont le comportement diffère (`:=` est beaucoup plus efficient). Par exemple, pour créer une nouvelle colonne, on adopte la syntaxe suivante:

```{r}
iris_dt
iris_dt[, "nouvelle_colonne" := Petal.Width*10]
iris_dt
``` 

Le `data.table` est ainsi modifié par référence, sans avoir besoin d'être réassigné avec le symbole `<-`. C'est ce comportement qui permet à `data.table` d'être très rapide et très peu gourmand en RAM, rendant son usage approprié pour des données de taille importante. 

Pour supprimer une colonne, on fait

```{r}
iris_dt[,'nouvelle_colonne' := NULL]
```


Pour créer les variables colA, colB et leur assigner les valeurs valA et valB:
```{r eval = F}
iris_dt[, c("colA", "colB") := list(Sepal.Length*5, Sepal.Width*5)]
# syntaxe qui produit le même résultat mais est plus préférable
iris_dt[, `:=`("colA" = get('Sepal.Length')*5, 
          "colB" = get('Sepal.Width')*5)]
```

Attention, lorsque l'on crée plusieurs variables ainsi, elles se créent en même temps. Si on crée des variables qui dépendent d'autres variables créées, il faut séparer l'opération en deux. 

### Remplacement conditionnel

L'opérateur `:=` peut être utilisé pour actualiser certaines lignes seulement, en fonction d'une condition logique. C'est beaucoup plus efficient qu'un terme `dplyr::if_else` ou `dplyr::case_when`. Imaginons qu'on désire créer une colonne x qui vale `Petal.Length` sauf pour les lignes où `Species` est `setosa` où elle vaut `NA`. Dans ce cas, le code `dplyr` serait:

```{r, eval = FALSE}
iris_dt %>% dplyr::mutate(x = dplyr::case_when(
    Species ~ "setosa" == NA_real_,
    TRUE ~ Petal.Length
))
```

et le code équivalent en `data.table`, nécessitant beaucoup moins de RAM:

```{r}
iris_dt[, "x" := Petal.Length]
iris_dt[Species == "setosa", x := NA_real_]
```

## .SD et lapply

## Fonctions modifiant un `data.table`

Il est très facile de créer des fonctions génériques modifiant un `data.table`
vs difficle en dplyr

