
```{r setup_tableur, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=TRUE, include=TRUE, message=FALSE, warning=FALSE, fig.height = 6, fig.width = 8)
```

# Importer des fichiers issus de tableurs (Excel, Calc)

## Tâches concernées et recommandations

L'utilisateur souhaite importer dans `R` des données issues de tableurs (extension type `xls`, `xlsx` ou `ods`).

::: {.recommandation data-latex=""}

- **Il est recommandé d'utiliser la fonction `read_ods` du _package_ `readODS` importer des fichiers `ods`.**
- **Il est recommandé, notamment pour des raisons de vitesse d'import, d'utiliser la fonction `read_xlsx()` du _package_ `openxlsx` pour importer des fichiers `xlsx`.**
- **Il est recommandé d'utiliser la fonction `read_excel()` du _package_ `readxl` pour importer des fichiers `xls`.**

Il est déconseillé d'utiliser le _package_ `xlsx`.
:::

## Import d'un fichier `ods` avec le _package_ `readODS`

### Introduction

Le _package_ `readODS` propose deux fonctions d'importation de fichiers `ods`: `read_ods` et `read.ods`. La documentation du _package_ recommande d'utiliser, autant que possible, `read_ods`. L'usage de cette fonction va être illustré à partir d'un jeu de données créé à partir de données présentes sur le site de l'Insee. Pour reproduire les exemples ci-dessous, vous devez:

- télécharger [le jeu de données ici (LIEU DE STOCKAGE A DEFINIR)](inactif) puis le sauvegarder sur votre poste;
- définir le chemin du fichier nommé `chemin_ods` . Voici un exemple:
  ```{r, eval=FALSE}
  chemin_ods <- "D:/mon_IDEP_Insee/Dossier_UtilitR/mes_donnees/mes_donnees.ods"
  ```

```{r, eval=TRUE, echo = FALSE}
# Définir le chemin du fichier
chemin_ods <- "./import_donnees_tabulees_tests/mes_donnees.ods"
```

Il ne faut pas oublier de charger le _package_ avec `library`.

```{r}
library(readODS)
```


### Présentation de la fonction `readODS::read_ods()`

Voici les principaux arguments et options de `read_ods()`:

| Argument            | Valeur par défaut     | Fonction                                                                                   |
|---------------------|-----------------------|--------------------------------------------------------------------------------------------|
| `path`              | Aucune                | Le chemin du fichier `ods` à importer                                                        |
| `sheet`             | 1                     | feuille à lire. Soit le nom de la feuille, soit un numéro de feuille entier.  |
| `col_names`         | TRUE                  | Indique si la première ligne du fichier contient les noms des variables               |
| `col_types`         | NULL                  | `NULL` pour laisser `R` deviner à partir de la feuille de calcul ou se reporter à `readr::type_convert` pour spécifier la spécification des cols. | 
| `na`                | ""                    | Vecteur de caractères des chaînes à utiliser pour les valeurs manquantes. Par défaut, `read_ods` convertit les cellules vides en données manquantes                                                                                         |
| `skip`              | 0                     | le nombre de lignes du fichier de données à ignorer avant de commencer à lire les données  |
| `range`             |  NULL                 | sélection d'un rectangle à l'aide d'une plage de cellules de type Excel, comme `range = "D12:F15"`. |

### Quelques exemples

* **Utilisation la plus simple**: on importe toutes les données du premier onglet, en supposant que la première ligne contient les noms de variables.

```{r}
# Chargement du 2ème onglet
mesDonnees <- readODS::read_ods(path = chemin_ods)
head(mesDonnees, 3)
```

* **Définir l'onglet à importer**: on importe toutes les données du second onglet, en supposant que la première ligne contient les noms de variables. On définit l'onglet à importer avec le paramètre `sheet` en précisant soit le nom de l’onglet soit son index (sa position dans le fichier). Il est conseillé d'utiliser le nom de l'onglet plutôt que sa position.

```{r}
# Chargement du 3ème onglet
mesDonnees <- readODS::read_ods(path = chemin_ods, sheet = "Sheet3")
```

::: {.remarque data-latex=""}
La fonction `readODS::ods_sheets()` permet de récupérer les différents noms d’onglets du fichier.
```{r}
# Récupération des noms d'onglet
readODS::ods_sheets(chemin_ods)
```
:::

* **Ne pas importer les x premières lignes ** Le paramètre `skip` permet de préciser à compter de quelle ligne commencer l'importation. Dans l'exemple ci-dessous, on n'importe les données qu'à compter de la cinquième ligne. Si on laisse le paramètre `col_names = TRUE`, la première de ces lignes est considérée comme *noms de colonnes*, ce qui peut donner des résultats absurdes. Si c'est le cas, on peut utiliser le paramètre `col_names=FALSE`.

```{r}
mesDonnees <- readODS::read_ods(path = chemin_ods, skip = 5, col_names = FALSE)
#  Nom des colonnes
head(mesDonnees, 3)
```

* **Importer une zone spécifique du fichier ** `range`  
Il est possible de n'importer qu'une plage de cellules en la définissant dans l'argument `range`. On peut également préciser l'onglet concerné, en écrivant la zone sous la forme `"Sheet1!B2:D7"`.

```{r }
mesDonnees <- readODS::read_ods(path = chemin_ods, range = "Sheet1!B2:D7")
head(mesDonnees, 3)
```

## Importer un fichier `xlsx` ou `xls`

### Avec l'interface graphique de RStudio

**Présentation de l'interface**

Rstudio propose une interface graphique très commode pour lire, entre autres, des fichiers `xls` et `xlsx` (mais aussi des tables `Sas` ou des fichiers `csv`, mais pas les `ods`). `R` utilise la fonction `read_excel` du _package_ `readxl` qui peut lire aisément des fichiers de type `xls` ou `xlsx` peu volumineux. On y accède avec: `File > Import Dataset > From Excel...`.  Les différents menus permettent notamment de sélectionner l'onglet et la zone à importer et de nommer la table d'affectation. Le grand intérêt de cette interface est qu'elle fournit le code utilisé pour importer les données. Vous pouvez donc le copier dans vos scripts pour le réutiliser, et ainsi vous familiariser avec les fonctions d'importation.


Dans ce premier exemple, on a importé l'onglet par défaut (`Sheet`), i.e. le 1er, de la table **mes_donnees.xlsx** (`File/Url`) qu'on a nommé **mes_donnees** (`Name`). On a gardé la 1ère ligne du fichier comme **noms de colones** (`First Row as Names`).

![IHM: Exemple 1](./import_donnees_tabulees_tests/img/1 import IHM.png)

Dans l'exemple suivant, on n'importe qu'une plage de données (`A1:D5`) de l'onglet nommé **Sheet3** (`Sheet`) de la même table qu'on a nommé de la même façon.

![IHM: Exemple 2](./import_donnees_tabulees_tests/img/2 import IHM avec param sheet range NA.png)

Dans ce dernier exemple, on n'importe qu'au maximum 10 lignes de l'onglet nommé **Sheet2** (`Sheet`), en débutant la sélection à la ligne numéro 3. On ne garde pas cette 1ère ligne comme **noms de colones**.

![IHM: Exemple 3](./import_donnees_tabulees_tests/img/3 import IHM avec param sheet maxRows skip.png)

### Présentation de la fonction `openxlsx::read.xlsx()`

Pour lire un fichier au format `xlsx`, nous préconisons d'utiliser la *fonction* `read.xlsx()` du *package* `openxlsx` d'autant plus si le fichier de données est volumineux.  Cette fiche s'appuie sur la version **4.1.5**.  
Cette fonction permet de charger les données du tableur dans un `data.frame`.

#### Les données utilisées

Nous travaillerons à partir d'un jeu de données fictif, créé pour l'occasion:  

- charger [le jeu de données ici (A définir)](inactif) puis le sauvegarder sur votre poste.
- Adapter en conséquence le chemin ci-dessous en remplaçant `./import_donnees_tabulees_tests` par votre chemin menant au fichier `/mes_donnees.xlsx`. **Exemple:** `D:/T19QHL/Mes Documents/R_workSpace/documentationR/mes_donnees`.

Nous définissons, en début de script, une variable contenant le chemin d'accès aux données.

```{r}
chemin_xlsx <- "./import_donnees_tabulees_tests/mes_donnees.xlsx"
```

#### Les paramètres

Voici les principaux arguments et options de `read.xlsx()`:

| Argument         | Valeur par défaut     | Fonction                                                                                   |
|------------------|-----------------------|--------------------------------------------------------------------------------------------|
| `xlsxFile`       | Aucune                | Chemin d'accès vers un objet classeur ou une url vers un fichier xlsx à importer           |
| `sheet`          | 1                     | Nom ou index de la feuille à partir de laquelle lire les données                           |
| `startRow`       | 1                     | Première ligne pour commencer à rechercher des données. Les lignes vides en haut d'un fichier sont toujours ignorées, quelle que soit la valeur de startRow                                                                                |
| `colNames`       | TRUE                  | Si `TRUE`, la première ligne de données sera utilisée comme nom de colonne                 |
| `rowNames`       | FALSE                 | Si `TRUE`, la première colonne de données sera utilisée comme noms de ligne                |
| `detectDates`    | FALSE                 | Si `TRUE`, essayer de reconnaître les dates et effectuer la conversion                     |
| `skipEmptyRows` | TRUE                   | Si `TRUE`, les lignes vides sont ignorées, sinon les lignes vides après la première ligne contenant les données renverront une ligne de `NA`                                                                                                |
| `skipEmptyCols`  | FALSE                 | Si `TRUE`, les colonnes vides sont ignorées                                                |
| `rows`           | NULL                  | Un vecteur numérique spécifiant les lignes du fichier à lire. Si NULL, toutes les lignes sont lues                                                                                                                                         |
| `cols`           | NULL                  | Un vecteur numérique spécifiant les colonnes du fichier Excel à lire. Si NULL, toutes les colonnes sont lues                                                                                                                               |
| `check.names`    | FALSE                 | Si `TRUE`, les noms des variables dans la trame de données sont vérifiés pour s'assurer qu'ils sont des noms de variable syntaxiquement valides                                                                                             | 
| `sep.names`      | "."                   | Un caractère qui remplace les blancs dans les noms de colonne                              |
| `namedRegion`    | NULL                  | Une région nommée dans le classeur. Si ce n'est pas NULL startRow, les paramètres lignes et cols sont ignorés                                                                                                                            |
| `na.strings`     | NA                    | Un vecteur de caractères de chaînes qui doit être interprété comme `NA` Les cellules vides seront retournées comme `NA`                                                                                                                   |

Les exemples qui suivent vont vous permettre de facilement charger tout ou partie d'une table de données d'un fichier avec une extension `.xlsx`.

### Pas à pas
* **charger le _package_**  
Le cas échéant, vous devrez commencer par **charger** le _package_ `openxlsx`
```{r}
library(openxlsx)
```
Vous pouvez également faire appel à la seule fonction du _package_ qui vous intéresse en la faisant précéder du `nom du package` et de `::`  
Exemple: `openxls::read.xls()`.  
C'est la méthode que nous appliquerons ici.

* **Définir des données à charger -** `xlsxFile` 
Par défaut, on charge le 1er onglet: on obtient alors un `data.frame`. Pour charger un autre onglet du même fichier, on utilisera le paramètre `sheet` en précisant soit le nom de l’onglet soit son index (sa position dans le fichier).  

```{r}
# Chargement du 2ème onglet
mesDonnees <- openxlsx::read.xlsx(xlsxFile = chemin_xlsx, sheet=2)
str(mesDonnees)
```
Le type des variables est conservé.

La fonction `openxlsx::getSheetNames()` permet de récupérer les différents noms d'onglets du fichier.
```{r}
(nomOnglets <- openxlsx::getSheetNames(chemin_xlsx))

```

```{r}
# Chargement d'un onglet par rapport à son nom
mesDonnees <- openxlsx::read.xlsx(xlsxFile = chemin_xlsx, sheet="Sheet3")
# Nom des colonnes
colnames(mesDonnees)
```

* **Préciser où débute la sélection -** `startRow`  
Par défaut, on importe les données à partir de la 1ère ligne de l'onglet spécifié. On peut, avec le paramètre `startRow`, définir la ligne de début d'import.
```{r}
mesDonnees <- openxlsx::read.xlsx(xlsxFile = chemin_xlsx, startRow=3)
# Les 10 premières lignes du data.frame
head(mesDonnees,10)
```

On perd les noms de colonnes et le type des variables.
```{r}
# Structure des données
str(mesDonnees)
```

* **Définir les en-têtes de colonnes -** `colNames`  
La 1ère ligne des données définit, par défaut, le nom des colonnes. Si on ne veut pas que ce soit le cas, on passe le paramètre `colNames=FALSE`.
```{r,eval = FALSE}
mesDonnees <- openxlsx::read.xlsx(xlsxFile = chemin_xlsx, colNames=FALSE)
# Nom des colonnes
colnames(mesDonnees)
```

La 1ère ligne est donc considérée comme une ligne de données comme les autres.
```{r}
# Les 10 premières lignes du data.frame
head(mesDonnees,10)
```
Par conséquent, il vous faudra, le cas échéant, préciser le nom des colonnes.

* **Ne pas importer les lignes et les colonnes vides -** `skipEmptyRows`  

Pour tester ce paramètre, vous pouvez ouvrir votre jeux de données (avec un tableur) et effacer les données d'une ligne et d'une colonne puis exécutez le code suivant:
```{r, eval=FALSE}
(mesDonnees <- openxlsx::read.xlsx(xlsxFile = chemin_xlsx, skipEmptyRows=TRUE))
```

Les données effacées ne seront pas chargées.

* **Sélectionner les lignes et colonnes à importer -** `rows` et `cols`  
On peut définir les lignes et colonnes qu'on souhaite importer en le précisant, avec un vecteur numéric, avec les paramètres `rows` et `cols`.
```{r}
(mesDonnees <- openxlsx::read.xlsx(xlsxFile = chemin_xlsx, rows=c(1,4:6,9), cols=c(1,3:4)))
```

* **Vérification du respect des normes syntaxiques dans les noms de variable -**  `check.names` et `sep.names`

La fonction `openxlsx::read.xlsx()` propose, via le paramètre `check.names` de modifier les noms de variables pour les adapter aux règles de bonnes pratiques syntaxiques. Dans tous les cas, les espaces dans les noms de variables sont remplacés par des **"."**.

Avec `check.names=FALSE`, *nom-de-variable* resterait inchangé et *nom de variable* deviendrait *nom.de.variable*.  
En passant `check.names=TRUE`, *nom-de-variable* devient *nom.de.variable*.

Le paramètre `sep.names` permet de préciser par quel caractère remplacer les espaces pour que ça ne soit plus forcément un **"."**.
Avec `sep.names="|"`, *nom-de-variable* resterait inchangé et *nom de variable* deviendrait *nom|de|variable*. 

* **Importer une zone spécifique du fichier -** `namedRegion`  
Il est possible de n'importer qu'une partie du fichier selon le nom d’une zone de la *"feuille de calcul"*.

Pour récupérer le nom des différentes parties de notre fichier, on utilise la méthode `openxlsx::getNamedRegions` à qui on passe le chemin du fichier. Ensuite, on passe l'une de ces zones au paramètre `namedRegion`.

Dans le cadre de cet exercice, vous pouvez créer une région (nommer une plage: **test_namedRegion**) avec votre tableur puis l'importer: 

```{r, eval=FALSE}
(mesDonnees <- openxlsx::read.xlsx(xlsxFile = chemin_xlsx, namedRegion="test_namedRegion"))
```

---

### Présentation de la fonction `readxl::read_excel()`

Pour lire un fichier au format `xls` (ce que ne fait pas le package `openxlsx`), éventuellement un fichier au format `xlsx` peu volumineux, vous pouvez utiliser la *fonction* `read_excel()` du *package* `readxl`.

#### Les données utilisées

Nous travaillerons à partir d'un jeu de données fictif, créé pour l'occasion:  

- charger [le jeu de données ici (A définir)](inactif) puis le sauvegarder sur votre poste.
- Adapter en conséquence le chemin ci-dessous en remplaçant `./import_donnees_tabulees_tests` par votre chemin menant au fichier `/mes_donnees.xlsx`. **Exemple:** `D:/T19QHL/Mes Documents/R_workSpace/documentationR/mes_donnees`.

Nous définissons, en début de script, une variable contenant le chemin d'accès aux données.

```{r}
# chemin_xlsx <- "Z:/EXERCICES DU COURS BDD.xlsx"
chemin_xls <- "./import_donnees_tabulees_tests/mes_donnees.xls"
```

#### Les paramètres

La fonction `read_excel()` du _package_ `readxl`, qui fait partie du `tidyverse`, permet d’importer des données directement depuis un fichier au format `xls` ou `xlsx`.

Voici les principaux arguments et options de `read_excel()`:


| Argument         | Valeur par défaut     | Fonction                                                                                   |
|------------------|-----------------------|--------------------------------------------------------------------------------------------|
| `path`           | Aucune                | Chemin d'accès au fichier xls / xlsx à importer                                            |
| `sheet`          | NULL                  | Feuille à lire. Soit une chaîne (le nom d'une feuille), soit un entier (la position de la feuille). Ignoré si la feuille est spécifiée via range. Par défaut, sélectionne le 1er onglet de la feuille                                       |
| `range`          | NULL                  | Une plage de cellules à lire. Comprend des plages Excel typiques comme "B3: D87", y compris éventuellement le nom de la feuille comme "Budget! B2: G14", et plus encore. Interprété strictement, même si la plage force l'inclusion de lignes ou de colonnes vides de début ou de fin. Prend le pas sur `skip`, `n_max` et `sheet`                                                    |
| `col_names`      | TRUE                  | `TRUE` pour utiliser la première ligne comme noms de colonne, `FALSE` pour obtenir les noms par défaut ou un vecteur de caractères donnant un nom à chaque colonne                                                                             |
| `col_types`      | NULL                  | Soit `NULL` pour deviner tout à partir de la feuille de calcul soit un vecteur de caractères contenant une entrée par colonne parmi ces options. Le contenu d'une cellule dans une colonne ignorée (`skip`) n'est jamais lu et cette colonne n'apparaîtra pas dans la sortie du bloc de données                                                                                                   |
| `na`             | ""                    | Vecteur de caractères de chaînes à interpréter comme des valeurs manquantes. Par défaut, `readxl` traite les cellules vides comme des données manquantes                                                                                  |
| `skip`           | 0                     | Nombre minimum de lignes à ignorer avant de lire quoi que ce soit. Les premières lignes vides sont automatiquement ignorées, il s'agit donc d'une limite inférieure. Ignoré si `range` est donné                                           |
| `n_max`          | Infini                | Nombre maximum de lignes de données à lire. Les lignes vides de fin sont automatiquement ignorées, il s'agit donc d'une limite supérieure du nombre de lignes dans le tibble retourné. Ignoré si `range` est donné                            |
| `guess_max`      | 1000 ou `n_max`       | Nombre maximal de lignes de données à utiliser pour deviner les types de colonnes          |
| `.name_repair`   |                       | Gestion des noms de colonne. Par défaut, `readxl` garantit que les noms de colonnes ne sont pas vides et sont uniques                                                                                                                         |

### Pas à pas

* **Charger le _package_**  
Le cas échéant, vous devrez commencer par **charger** le _package_ `readxl`
```{r}
library(readxl)
```
Vous pouvez également faire appel à la seule fonction du _package_ qui vous intéresse en la faisant précéder du `nom du package` et de `::`
Exemple: `readxl::read_excel()`.  
C'est la méthode que nous appliquerons ici.

* **Définir des données à charger -** `path` 

Par défaut, on charge le 1er onglet: on obtient alors un `tibble`. Pour charger un autre onglet du même fichier, on utilisera le paramètre `sheet` en précisant soit le nom de l’onglet soit son index (sa position dans le fichier)

```{r}
# Chargement du 2ème onglet
mesDonnees <- readxl::read_excel(path = chemin_xls, sheet=2)
str(mesDonnees)
```
Le type des variables est conservé.

La fonction `readxl::excel_sheets()` permet de récupérer les différents noms d'onglets du fichier.
```{r}
(nomOnglets <- readxl::excel_sheets(chemin_xls))
```

```{r}
# Chargement d'un onglet par rapport à son nom
mesDonnees <- readxl::read_excel(path = chemin_xls, sheet="Sheet3")
# Structure des données
str(mesDonnees)
```

* **Définir les en-têtes de colonnes -** `col_names`  
La 1ère ligne des données définit, par défaut, le nom des colonnes. Si on ne veut pas que ce soit le cas, on passe le paramètre `colNames=FALSE`. Les colonnes serot alors numérotées.
```{r}
mesDonnees <- readxl::read_excel(path = chemin_xls, col_names=FALSE)
# Nom des colonnes
colnames(mesDonnees)
```
La 1ère ligne est donc considérée comme une ligne de données comme les autres.
```{r}
# Les 10 premières lignes du tible
head(mesDonnees,10)
```
Par conséquent, il vous faudra, le cas échéant, préciser le nom des colonnes.

* **Importer une zone spécifique du fichier -** `range`  
Il est possible de n'importer qu'une plage de cellules en la définissant comme ceci: **Exemple: "B2:D7"**. On peut également préciser l'onglet avant: **"Sheet3!B2:D7"**

```{r}
(mesDonnees <- readxl::read_excel(path = chemin_xls, range = "Sheet3!B2:D7"))
```
Le type des variables est conservé et la 1ère ligne de la plage est considérée comme *en-tête de colonnes*: si ça ne doit pas être le cas, ajouter le paramètre `col_names=FALSE`.

* **Définir le type des colonnes -** `col_types`

le paramètre `col_types` permet de (re)définir le type des colonnes, d'une part, de "sauter" les colonnes qu'on ne souhaite pas importer d'autre part. Pour cela, on passe au paramètre `col_types` un vecteur précisant le type parmi les possibilités suivantes:  
* `"skip"`: permet de sauter une colonne qui ne sera pas importée;
* `"guess"`: le type de la variable est "devinée" par rapport à ses *modalités*;
* `"list"`: crée une liste.  
* et `"logical`, `"numeric"`, `"date"` ou `"text"`.
Le type de la variable sera appliqué aux colonnes dans l'ordre défini par le vecteur. Exemple: `c("text","text","numeric","guess","skip","logical")`. Dans le cas où on souhaite définir le même type à toutes les colonnes, on écrita juste le type attendu entre *""*. Par exemple `col_types = "text"`.

```{r}
mesDonnees <- readxl::read_excel(path = chemin_xls, col_types = c("text","list",rep("skip",9), "text", "numeric", "text", "guess"))
str(mesDonnees)
```

* **Gestion des *NA* -** `NA`  
Il est possible de préciser les valeurs qu'on souhaite considérer comme des `NA`. Ici, pour l'exercice, la valeur `75`.
```{r}
(mesDonnees <- readxl::read_excel(path = chemin_xls, na="75"))
```

* **Appliquer une fonction pour formatter les noms de colonnes -** `.name_repair`
`.name_repair` permet d'appliquer un format aux noms de colonnes. Dans l'exemple suivant, on passe les noms de colonnes en MAJUSCULE.
```{r}
mesDonnees <- readxl::read_excel(path = chemin_xls, .name_repair = toupper)
names(mesDonnees)
```

Dans cet exemple, on applique une fonction crée pour l'occasion qui vise à remplacer les *"espaces"* par des `_` et passe le tout en majuscule.

```{r}
my_custom_name_repair <- function(nms) toupper(gsub("[[:space:]]", "_", nms))
mesDonnees <- readxl::read_excel(path = chemin_xls, .name_repair = my_custom_name_repair)
names(mesDonnees)
```

* **Ne pas importer les x premières lignes -** `skip`
On n'importe pas les 5 premières lignes. Par conséquent, l'import commence à la 6ème ligne: on peut passer le paramètre `col_names=FALSE` pour qu'elle ne soit pas considérée comme entête de colonnes.
```{r}
(mesDonnees <- readxl::read_excel(path = chemin_xls, skip = 5, col_names = FALSE))
names(mesDonnees)
```

* **Importer un nombre maximum de lignes -**`n_max`
On importe maximum 3 lignes
```{r}
(mesDonnees <- readxl::read_excel(path = chemin_xls, n_max = 3))
names(mesDonnees)
```

## Ressources

* [Package `openxlsx`](https://cran.r-project.org/web/packages/openxlsx/openxlsx.pdf);
* [Package `readxl`](https://cran.r-project.org/web/packages/readxl/readxl.pdf);
* [Package `readODS`](https://cran.r-project.org/web/packages/readODS/readODS.pdf);
* [vignette `readr`](https://cran.r-project.org/web/packages/readr/vignettes/readr.html)
