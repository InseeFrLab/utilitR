# Qualit√© du code {#code-quality}

## T√¢ches concern√©es et recommandations

Blabla

::: {.callout-recommandation .icon}
- lintr & styler
- Il faut utiliser une [**fonction**]{.red2} d√®s qu'on utilise une m√™me
portion de code plus de deux fois ([**_don't repeat yourself_ (DRY)**])

:::

Cette partie d√©taille de mani√®re plus √©tendue les √©l√©ments enseign√©s
dans le cadre d'une formation aux bonnes pratiques 
construite par l'Insee et dont les supports ont √©t√© ouverts √† 
[cette adresse](https://inseefrlab.github.io/formation-bonnes-pratiques-R/#/title-slide).


## Enjeux


Lors de l'apprentissage d'un langage, il est assez naturel de voir le code d‚Äôune mani√®re tr√®s fonctionnelle : on d√©sire r√©aliser une t√¢che donn√©e ‚Äî par exemple nettoyer des champs textuels ‚Äî et
on va donc assembler dans un script des bouts de code, souvent trouv√©s sur internet, jusqu‚Äô√† obtenir un projet qui r√©alise la t√¢che voulue.
La structure du projet importe assez peu, tant qu‚Äôelle permet d‚Äôimporter et traiter les donn√©es n√©cessaires √† la t√¢che en question.

Si cette approche flexible et minimaliste fonctionne tr√®s bien lors de la phase d‚Äôapprentissage, il est malgr√© tout indispensable de s‚Äôen d√©tacher progressivement √† mesure qu‚Äôon progresse et que l‚Äôon peut √™tre amen√© √† r√©aliser des projets collaboratifs ou amen√©s √† durer dans le temps.

Lorsqu'on travaille avec R, il est important de consid√©rer
le code non seulement comme un outil pour effectuer des t√¢ches,
mais aussi comme un __moyen de communiquer__
nos m√©thodes et r√©sultats √† d'autres personnes.
En adoptant des bonnes pratiques, on am√©liore la lisibilit√©
et la compr√©hension d'un code, ce qui facilite la collaboration avec
les r√©utilisateurs du code mais aussi aupr√®s de publics, comme les
chercheurs, d√©sirant 
comprendre les traitements mis en oeuvre.

La __lisibilit√©__ et la __maintenabilit√©__ du code
sont des aspects cl√©s pour assurer la qualit√© d'un projet statistique.
Les bonnes pratiques aident √† √©crire du code clair et structur√©, ce qui fait gagner du temps pour s'approprier un code, corriger des erreurs ou apporter des modifications √† un code.
Un code √©tant plus souvent lu qu'√©crit[^1]

[^1]: Cette phrase tr√®s connue est une citation de Guido Van Rossum, le cr√©ateur
de `Python`. `R` comme `Python` tous deux des langages con√ßus pour √™tre plus
transparents que des langages bas niveaux comme `C`. 

La __r√©utilisation__ d'un code ou de productions associ√©es √† du code,
comme des bases
de donn√©es, peut √™tre grandement facilit√©e en adoptant des bonnes pratiques.


Gr√¢ce aux bonnes pratiques, nous pouvons nous assurer que notre
travail est __transparent__ et facilement __v√©rifiable__.
Cette exigence de reproductibilit√©, notion centrale dans le domaine de la recherche
scientifique, s'applique √©galement
dans d'autres domaines o√π la transparence m√©thodologique est cruciale pour la validit√© et la fiabilit√© des r√©sultats. Un code de qualit√© facilite ainsi 
la v√©rification et la reproduction de nos r√©sultats par d'autres personnes.
A l'image du processus de revue par les pairs (_peer review_)
dans le domaine scientifique,
se d√©veloppent des revues de code (_code review_) qui favorisent la production
d'un code de qualit√©. 


## Adopter les standards communautaires

### Enjeux

> *"Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread"*
>
> [Tidyverse Style Guide](https://style.tidyverse.org/)

Tout comme la correction de la ponctuation peut rendre un texte plus facile √† lire,
une bonne pratique de codage peut rendre notre code plus facile √† comprendre
√† maintenir et √† r√©utiliser.

Il est √©galement important de respecter les conventions du langage dans lequel le code est r√©dig√©. Cela peut inclure des normes de formatage telles que l'indentation et la mise en forme, ainsi que des conventions de nommage telles que les noms de variables et de fonctions. En utilisant les conventions standardis√©es du langage, nous pouvons rendre notre code plus coh√©rent et plus facile √† comprendre pour les autres personnes travaillant dans ce langage.

Il existe deux guides de r√©f√©rence qui exposent les conventions de la communaut√©
`R` concernant la qualit√© du code :
le [_`Tidyverse` style guide_](https://style.tidyverse.org/) et
le [_`Google` style guide_](https://google.github.io/styleguide/Rguide.html).
Ces guides proposent des conseils sur la fa√ßon d'√©crire du code
clair et structur√© en utilisant les bonnes pratiques recommand√©es pour le langage `R`.
Il est utile de lire les introductions et de se r√©f√©rer ponctuellement √† ceux-ci
pour s'assurer d'adopter des bonnes pratiques en mati√®re de codage en `R`.

::: {.callout-remarque .icon}

Ces deux guides diff√®rent sur certaines r√®gles syntaxiques. 

Par exemple,
le  [_`Tidyverse` style guide_](https://style.tidyverse.org/functions.html#return) recommande de
ne pas introduire de `return` en fin de fonction alors que 
le [_`Google` style guide_](https://google.github.io/styleguide/Rguide.html#use-explicit-returns)
pr√©conise de le faire. Les deux conventions peuvent se d√©fendre 
et le choix entre les deux rev√™t une forme d'arbitraire. Par exemple, si on 
privil√©gie la lisibilit√©, il est conseill√© de toujours avoir un `return` alors
que quelqu'un favorisant la concision n'utilisera pas de `return`. De m√™me,
le choix entre _camel case_ (objets dont les mots sont d√©limit√©s avec des majuscules comme
`addValues`) dans le [_`Google` style guide_](https://google.github.io/styleguide/Rguide.html#naming-conventions)
et _snake case_ (s√©paration avec des `_` comme `add_values`) propos√© par
 [_`Tidyverse` style guide_](https://style.tidyverse.org/syntax.html#object-names)
 est arbitraire. 
 
 Comme il est difficile de donner des arguments objectifs pour privil√©gier une r√®gle
 plut√¥t qu'une autre, il n'est pas impossible de parfois suivre celles du 
[_`Tidyverse` style guide_](https://style.tidyverse.org/) et
d'autre fois celles du [_`Google` style guide_](https://google.github.io/styleguide/Rguide.html). 
L'important est plut√¥t d'√™tre coh√©rent dans le cadre d'un projet en suivant les
m√™mes conventions dans l'ensemble des scripts qui le constituent. 

:::



### Outils

Pour mettre de mani√®re automatis√©e certaines des r√®gles syntaxiques
pr√©sentes dans les guides, il existe plusieurs types d'outils.

* Un [**_linter_**]{.orange} est un programme qui v√©rifie que le code est __formellement__ conforme √† un certain _guidestyle_, et signale les erreurs. En revanche, un _linter_ ne modifie pas directement le code et ne rep√®re pas les erreurs de fond.
* Un [**_formatter_**]{.orange} est un programme qui reformate un code source pour le rendre conforme √† un certain _guidestyle_. Par d√©finition, un _formatter_ modifie directement le code.

Un **linter** se comporte un peu comme un correcteur d'un traitement de texte 
dont on aurait d√©sactiv√© la fonction de remplacement automatique. Le
formatter correspond plut√¥t au correcteur automatique du t√©l√©phone portable
qui va corriger automatiquement ce qu'il juge √™tre des erreurs. 




::: {.callout-remarque .icon}

- [Exemples d‚Äôerreurs rep√©r√©es]{.blue2} par un _linter_ : 
    + lignes de code trop longues ou mal indent√©es, parenth√®ses non √©quilibr√©es, noms de fonctions mal construits‚Ä¶
- [Exemples d‚Äôerreurs __non__ rep√©r√©es]{.blue2} par un _linter_ :
    + fonctions mal utilis√©es, arguments mal sp√©cifi√©s, structure du code incoh√©rente, code insuffisamment document√©‚Ä¶
:::

Dans le cas de {{< fa brands r-project >}} : 

- le [_linter_]{.orange} √† utiliser est le _package_ [`lintr`](https://github.com/r-lib/lintr);
- le [_formatter_]{.orange} √† utiliser est le _package_ [`styler`](https://github.com/r-lib/styler).

::: {.callout-conseil .icon}

Pour que `lintr` utilise le guide de style `tidyverse`, il suffit

```{r}
#| eval: false
lintr::use_lintr(type = "tidyverse")
```

:::


## Utiliser des fonctions

L'utilisation de fonctions est l'une des bonnes pratiques en mati√®re
de programmation qui s'applique √† tous les langages de programmation,
y compris `R`.

La r√®gle _DRY_ pour _do not repeat yourself_ (ne pas se r√©p√©ter)
indique qu'il faut √©viter de copier-coller du code lorsqu'il est utilis√© plus de deux fois.
Au lieu de cela, on devrait encapsuler ce code dans une fonction et utiliser
cette fonction aux endroits o√π cela est n√©cessaire.


En premier lieu, cela limiter les risques d'erreurs li√©es au copier-coller de code.
Si une modification est n√©cessaire, elle peut √™tre apport√©e dans la fonction, ce qui garantit que toutes les utilisations de la fonction seront automatiquement mises √† jour.

Ne pas se r√©p√©ter rend √©galement le code plus lisible et plus compact en encapsulant un traitement sp√©cifique dans une section distincte du code.
Ceci pr√©sente √©galement l'avantage de n'avoir qu'un 
seul endroit du code √† modifier
lorsqu'on souhaite apporter une modification au traitement.
Cela peut repr√©sente une √©conomie de temps substantielle
et minimiser les erreurs.

Enfin, utiliser des fonctions facilite la r√©utilisation et la documentation
du code. D'abord parce qu'en encapsulant un traitement dans une fonction, on peut facilement le r√©utiliser dans d'autres parties du code. Ensuite, parce que cela peut
√©galement faciliter la documentation du code en permettant de d√©crire clairement ce que fait chaque fonction.

Un biais √† √©viter est le [code spaghetti](https://fr.wikipedia.org/wiki/Programmation_spaghetti)
Il s'agit d'un code qui est difficile √† comprendre et √† maintenir en raison de sa complexit√© et de sa structure d√©sorganis√©e. 
Pour √©viter le code spaghetti, il est important de suivre certaines r√®gles pour √©crire des fonctions pertinentes. Voici les trois principales r√®gles √† retenir :

* _Une t√¢che = une fonction_ : chaque fonction devrait effectuer une seule t√¢che sp√©cifique. Cela permet de rendre le code plus clair et plus facile √† comprendre.

* _Une t√¢che complexe = un encha√Ænement de fonctions r√©alisant chacune une t√¢che simple_ : si une t√¢che est complexe, elle peut √™tre divis√©e en plusieurs t√¢ches plus simples et encapsul√©es dans des fonctions distinctes. Cela permet de rendre le code plus facile √† comprendre et √† maintenir.

* _Limiter l'utilisation de variables globales_ : les variables globales sont accessibles depuis n'importe quel endroit du code, ce qui peut rendre le code difficile √† comprendre et √† maintenir. Il est donc recommand√© de limiter l'utilisation de variables globales et d'utiliser des variables locales au lieu de cela. Cela permet de rendre le code plus clair et plus facile √† comprendre.

## Documenter son code

Les grands principes de la documentation de code consistent √† :

* Documenter le pourquoi plut√¥t que le comment : il est plus important de comprendre pourquoi le code a √©t√© √©crit de la mani√®re dont il l'a √©t√©, plut√¥t que de conna√Ætre les d√©tails techniques de son fonctionnement. En documentant le pourquoi, on peut mieux comprendre le but du code et comment il s'int√®gre dans le projet plus global.

* Privil√©gier l'auto-documentation via des nommages pertinents : le code peut √™tre plus clair et plus facile √† comprendre si les variables, les fonctions et les autres √©l√©ments ont des noms pertinents et explicites. Cela permet de documenter le code de mani√®re implicite et de rendre la lecture du code plus intuitive.

En gardant ces grands principes √† l'esprit, on peut √©crire du code qui est plus facile √† comprendre et √† maintenir, ce qui peut √©conomiser du temps et des ressources dans le long terme.

. . .

::: {.callout-conseil .icon}

Comment bien documenter un script ?

- [**Minimum**]{.orange} üö¶ : commentaire au d√©but du script pour d√©crire ce qu'il fait ;
- [**Bien**]{.orange} üëç : commenter les parties "d√©licates" du code ;
- [**Id√©al**]{.orange} üí™ : documenter ses fonctions avec la syntaxe `roxygen2`.

:::


## Pas d'ambigu√Øt√© sur les _packages_ utilis√©s

Deux fonctions peuvent avoir le m√™me nom dans des packages diff√©rents. Par
exemple, la fonction `select` existe dans les packages `dplyr` et `MASS`.
En utilisant `R`, le package charg√© la plus r√©cemment via `library`
sera utilis√©e par d√©faut.

Cela peut causer des erreurs difficiles √† rep√©rer,
car il est n√©cessaire d'ex√©cuter le code pour les d√©tecter. Par exemple, le code suivant 

```{r}
#| error: true
library(dplyr)
library(MASS)
bpe_ens_2018 <- doremifasolData::bpe_ens_2018

nombre <- bpe_ens_2018 %>%
  as_tibble() %>%
  select(TYPEQU, NB_EQUIP) 
```

renvoie une erreur difficile √† comprendre si on ne l'a pas d√©j√† rencontr√©e. 
Cela provient du fait que `MASS` √©tant le dernier _package_ charg√©, `R`
utilise sa fonction `select` plut√¥t que celle de `dplyr`.

Afin d'√©viter ces erreurs, il est recommand√© de r√©server
`library(pkg)` aux packages dont on utilise des fonctions √† de
nombreuses reprises dans un code. Il est recommand√©, pour les autres,
d'indiquer explicitement le package en utilisant la notation `package::fonction()`.
De m√™me, si une fonction pr√©sente le m√™me nom dans deux packages, il est recommand√©
d'utiliser cette notation. Cela permet de garantir que la bonne fonction est appel√©e et d'√©viter les erreurs potentielles.


:::{.callout-conseil}
## Le_package_[`conflicted`](https://github.com/r-lib/conflicted#conflicted)

Le_package_`conflicted` aide √† g√©rer les conflits de_packages_de mani√®re fluide.
:::

## Ressources suppl√©mentaires

<br>

- [_R Packages_](https://r-pkgs.org/man.html) par Hadley Wickham and Jenny Bryan
- Une [pr√©sentation tr√®s bien faite](https://mitmat.github.io/slides/2022-05-26-egu/code-data-open-science.html#1)
- [Un cours complet](https://eliocamp.github.io/reproducibility-with-r/) sur la reproductibilit√© avec `R`
- L'√©quivalent `Python` en [3A d'ENSAE](https://ensae-reproductibilite.netlify.app/about/)


## Exercices

TO BE COMPLETED