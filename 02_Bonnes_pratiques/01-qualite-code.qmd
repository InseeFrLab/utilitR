# Qualit√© du code {#code-quality}

::: {.callout-important}
## T√¢che concern√©e et recommandation

L'utilisateur souhaite am√©liorer la qualit√© de ses scripts `R` pour favoriser leur lisibilit√© et leur maintenabilit√©.

- Il est recommand√© d'utiliser le _package_ `lintr` pour obtenir des diagnostics de qualit√© du code.
- Il est recommand√© d'utiliser le _package_ `styler` pour effectuer des reformatages automatiques d'un script.
- D√®s qu'on utilise une m√™me portion de code plus de deux fois, il convient de la transformer en fonction (principe du _don't repeat yourself_).
- Il est conseill√© d'adopter la
notation `package::function` lorsqu'un _package_ n'est utilis√© que pour un
nombre r√©duit de fonctions ou lorsque des fonctions issues de _packages_ diff√©rents portent le m√™me nom. 
:::

Cette partie d√©taille de mani√®re plus √©tendue les √©l√©ments enseign√©s
dans le cadre d'une formation aux bonnes pratiques 
construite par l'Insee et dont les supports ont √©t√© ouverts √† 
[cette adresse](https://inseefrlab.github.io/formation-bonnes-pratiques-R/#/title-slide).


## Enjeux


Lors de l'apprentissage d'un langage, il est assez naturel de voir le code d‚Äôune mani√®re tr√®s fonctionnelle : on d√©sire r√©aliser une t√¢che donn√©e ‚Äî par exemple nettoyer des champs textuels ‚Äî et
on va donc assembler dans un script des bouts de code, souvent trouv√©s sur internet, jusqu‚Äô√† obtenir un projet qui r√©alise la t√¢che voulue.
La structure du projet importe assez peu, tant qu‚Äôelle permet d‚Äôimporter et traiter les donn√©es n√©cessaires √† la t√¢che en question.

Si cette approche flexible et minimaliste fonctionne tr√®s bien lors de la phase d‚Äôapprentissage, il est malgr√© tout indispensable de s‚Äôen d√©tacher progressivement √† mesure qu‚Äôon progresse et que l‚Äôon peut √™tre amen√© √† r√©aliser des projets collaboratifs ou amen√©s √† durer dans le temps.

Lorsqu'on travaille avec `R`, il est important de consid√©rer
le code non seulement comme un outil pour effectuer des t√¢ches,
mais aussi comme un __moyen de communiquer__
nos m√©thodes et r√©sultats √† d'autres personnes.
En adoptant des bonnes pratiques, on am√©liore la lisibilit√©
et la compr√©hension d'un code, ce qui facilite la collaboration avec
les r√©utilisateurs du code mais aussi aupr√®s de publics ext√©rieurs, comme les
chercheurs qui souhaitent comprendre les traitements mis en oeuvre.

La __lisibilit√©__ et la __maintenabilit√©__ du code
sont des aspects cl√©s pour assurer la qualit√© d'un projet statistique.
Les bonnes pratiques aident √† √©crire du code clair et structur√©, ce qui fait gagner du temps pour s'approprier un code (lisibilit√©), corriger des erreurs ou apporter des modifications √† un code (maintenabilit√©).
Un code √©tant plus souvent lu qu'√©crit[^1], c'est en effet la phase de maintenance d'un code qui s'av√®re la plus co√ªteuse, et non sa r√©daction initiale.

[^1]: Cette phrase tr√®s connue est une citation de Guido Van Rossum, le cr√©ateur
de `Python`. `R` comme `Python` sont des langages con√ßus pour √™tre plus
transparents et faciles √† lire que des langages bas niveaux comme `C`. 

La __r√©utilisation__ d'un code ou de productions associ√©es √† du code,
comme des bases
de donn√©es, peut √™tre grandement facilit√©e en adoptant des bonnes pratiques.


Gr√¢ce aux bonnes pratiques, nous pouvons nous assurer que notre
travail est __transparent__ et facilement __v√©rifiable__.
Cette exigence de __reproductibilit√©__, notion centrale dans le domaine de la recherche scientifique, s'applique √©galement
dans d'autres domaines o√π la transparence m√©thodologique est cruciale pour la validit√© et la fiabilit√© des r√©sultats. Un code de qualit√© facilite ainsi 
la v√©rification et la reproduction de nos r√©sultats par d'autres personnes.
A l'image du processus de revue par les pairs (_peer review_)
dans le domaine scientifique,
se d√©veloppent des revues de code (_code review_) qui favorisent la production
d'un code de qualit√©. 


## Adopter les standards communautaires

### Enjeux

> *"Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread"*
>
> [Tidyverse Style Guide](https://style.tidyverse.org/)

Tout comme la correction de la ponctuation peut rendre un texte plus facile √† lire,
une bonne pratique de codage peut rendre notre code plus facile √† comprendre,
√† maintenir et √† r√©utiliser.

Il est notamment important de respecter les conventions du langage dans lequel le code est r√©dig√©. Cela peut inclure des normes de formatage telles que l'indentation et la mise en forme, ainsi que des conventions de nommage telles que les noms de variables et de fonctions. En utilisant les conventions standardis√©es du langage, nous pouvons rendre notre code plus coh√©rent et plus facile √† comprendre pour les autres personnes travaillant dans ce langage.

Il existe deux guides de r√©f√©rence qui exposent les conventions de la communaut√©
`R` concernant la qualit√© du code :
le [_`Tidyverse` style guide_](https://style.tidyverse.org/) et
le [_`Google` style guide_](https://google.github.io/styleguide/Rguide.html).
Ces guides proposent des conseils sur la fa√ßon d'√©crire du code
clair et structur√© en utilisant les bonnes pratiques recommand√©es pour le langage `R`.
Il est utile de lire les introductions et de se r√©f√©rer ponctuellement √† ceux-ci
pour s'assurer d'adopter des bonnes pratiques en mati√®re de codage en `R`.

::: {.callout-note}

Ces deux guides diff√®rent sur certaines r√®gles syntaxiques. 

Par exemple,
le  [_`Tidyverse` style guide_](https://style.tidyverse.org/functions.html#return) recommande de
ne pas introduire de `return` en fin de fonction alors que 
le [_`Google` style guide_](https://google.github.io/styleguide/Rguide.html#use-explicit-returns)
pr√©conise de le faire. Les deux conventions peuvent se d√©fendre 
et le choix entre les deux rev√™t une forme d'arbitraire. Par exemple, si on 
privil√©gie la lisibilit√©, il est conseill√© d'inclure syst√©matiquement un `return` dans les fonctions, alors
qu'un d√©veloppeur cherchant la concision n'utilisera pas de `return`. De m√™me,
le choix entre _camel case_ (objets dont les mots sont d√©limit√©s avec des majuscules comme
`addValues`) dans le [_`Google` style guide_](https://google.github.io/styleguide/Rguide.html#naming-conventions)
et _snake case_ (s√©paration avec des `_` comme `add_values`) propos√© par
 [_`Tidyverse` style guide_](https://style.tidyverse.org/syntax.html#object-names)
 est arbitraire. 
 
Comme il est difficile de donner des arguments objectifs pour privil√©gier une r√®gle
 plut√¥t qu'une autre, il n'est pas impossible de parfois suivre celles du 
[_`Tidyverse` style guide_](https://style.tidyverse.org/) et
dans d'autres occasions celles du [_`Google` style guide_](https://google.github.io/styleguide/Rguide.html). 
L'important est plut√¥t d'√™tre coh√©rent dans le cadre d'un projet en suivant les
m√™mes conventions dans l'ensemble des scripts qui le constituent. 

:::



### Outils

Pour impl√©menter de mani√®re automatis√©e certaines des r√®gles syntaxiques
pr√©sentes dans les guides, il existe plusieurs types d'outils.

* Un [**_linter_**]{.orange} est un programme qui v√©rifie que le code est __formellement__ conforme √† un certain _style guide_, et signale les erreurs. En revanche, un _linter_ ne modifie pas directement le code et ne rep√®re pas les erreurs de fond.
* Un [**_formatter_**]{.orange} est un programme qui reformate un code source pour le rendre conforme √† un certain _style guide_. Par d√©finition, un _formatter_ modifie directement le code.

Un _linter_ se comporte un peu comme un correcteur orthographique d'un traitement de texte 
dont on aurait d√©sactiv√© la fonction de remplacement automatique. Le
_formatter_ correspond plut√¥t au correcteur automatique d'un t√©l√©phone portable
qui corrige automatiquement ce qu'il consid√®re comme des erreurs. 




::: {.callout-note}

- [Exemples d‚Äôerreurs rep√©r√©es]{.blue2} par un _linter_ : 
    + lignes de code trop longues ou mal indent√©es, parenth√®ses non √©quilibr√©es, noms de fonctions mal construits‚Ä¶
- [Exemples d‚Äôerreurs __non__ rep√©r√©es]{.blue2} par un _linter_ :
    + fonctions mal utilis√©es, arguments mal sp√©cifi√©s, structure du code incoh√©rente, code insuffisamment document√©‚Ä¶
:::

Dans le cas de `R` : 

- le [_linter_]{.orange} √† utiliser est le _package_ [`lintr`](https://github.com/r-lib/lintr);
- le [_formatter_]{.orange} √† utiliser est le _package_ [`styler`](https://github.com/r-lib/styler).

::: {.callout-tip}

Pour que `lintr` utilise le guide de style `tidyverse`, il suffit

```{r}
#| eval: false
lintr::use_lintr(type = "tidyverse")
```

:::

Pour utiliser un _linter_ sur l'ensemble des scripts d'un projet `R`,
la commande consacr√©e est :

```{r}
lintr::lint_dir()
```

Le _linter_ renvoie une suite, plus ou moins longue selon la qualit√©
du projet, de d√©rogations aux bonnes pratiques. 

![](../pics/bonnespratiques/linter.png)
Le _linter_ ne faisant pas les corrections automatiquement,
il est donc n√©cessaire d'ouvrir le fichier, se rendre √† la ligne
correspondante, et corriger. Les lignes indiqu√©es ne sont pas mises √† 
jour automatiquement, elles peuvent donc ne plus correspondre √† celles
du fichier lors de la phase de modifications. Il est donc pratique
de faire tourner r√©guli√®rement le _linter_ lors d'une phase de 
nettoyage. 

Il est √©galement possible de n'√©valuer qu'un fichier
avec `lintr::lint`:

```{r}
#| eval: false
lintr::lint("mesfonctions_pour_faire_ceci.R")
```

```{r}
#| echo: false
lintr::lint("../mesfonctions_pour_faire_ceci.R")
```

Le package `styler` propose le m√™me type de fonctions qui vont quant √† elles
modifier le code:

- Pour modifier un seul script, la fonction √† utiliser est `styler::style_file` ;
- Pour modifier l'ensemble des scripts d'un dossier, la fonction √† utiliser est `styler::style_dir`


## Utiliser des fonctions

### Pourquoi utiliser des fonctions?

L'utilisation de fonctions est l'une des bonnes pratiques en mati√®re
de programmation qui s'applique √† tous les langages de programmation,
y compris `R`.

La r√®gle _DRY_ pour _do not repeat yourself_ (ne pas se r√©p√©ter)
indique qu'il faut √©viter de copier-coller du code lorsqu'il est utilis√© plus de deux fois.
Au lieu de cela, on devrait encapsuler ce code dans une fonction et utiliser
cette fonction aux endroits o√π cela est n√©cessaire.

Utiliser des fonctions pr√©sente plusieurs avantages:


- Utiliser des fonctions r√©duit les risques d'erreurs li√©es au copier-coller de code. Si une modification est n√©cessaire, elle peut √™tre apport√©e dans la fonction, __√† un seul endroit du code__, ce qui garantit que toutes les utilisations de la fonction seront automatiquement mises √† jour. Cette pratique minimise les erreurs et peut repr√©senter une √©conomie de temps substantielle dans un gros projet.

- Utiliser des fonctions rend √©galement le code plus lisible et plus compact en encapsulant un traitement sp√©cifique dans une section distincte du code.

- Utiliser des fonctions facilite la r√©utilisation et la documentation
du code. D'une part parce qu'en encapsulant un traitement dans une fonction, on peut facilement le r√©utiliser dans d'autres parties du code. D'autre part, parce que d√©crire clairement ce que fait chaque fonction contribue √† documenter le code dans son ensemble.

Enfin, un nom bien choisi pour une fonction donne d√©j√† une bonne id√©e de ce √† quoi elle sert, facilitant en cela la compr√©hension d'une cha√Æne de traitements.

### Comment bien utiliser les fonctions?

Un biais √† √©viter est le [code spaghetti](https://fr.wikipedia.org/wiki/Programmation_spaghetti).
Il s'agit d'un code qui est difficile √† comprendre et √† maintenir en raison de sa complexit√©, de sa longueur et de sa structure d√©sorganis√©e. 
Pour √©viter le code spaghetti, il est important de suivre certaines r√®gles pour √©crire des fonctions pertinentes. Voici les trois principales r√®gles √† retenir :

* _Une t√¢che = une fonction_ : chaque fonction devrait effectuer une seule t√¢che sp√©cifique. Cela permet de rendre le code plus clair et plus facile √† comprendre.

* _Une t√¢che complexe = un encha√Ænement de fonctions r√©alisant chacune une t√¢che simple_ : si une t√¢che est complexe, elle peut √™tre divis√©e en plusieurs t√¢ches plus simples et encapsul√©es dans des fonctions distinctes. Cela permet de rendre le code plus facile √† comprendre et √† maintenir.

* _Limiter l'utilisation de variables globales_ : les variables globales sont accessibles depuis n'importe quel endroit du code, ce qui peut rendre le code difficile √† comprendre et √† maintenir. Il est donc recommand√© de limiter l'utilisation de variables globales et d'utiliser des variables locales au lieu de cela. Cela permet de rendre le code plus clair et plus facile √† comprendre.

## Auto-documenter son code

Les grands principes de la documentation de code consistent √† :

* Documenter le pourquoi plut√¥t que le comment : il est plus important de comprendre pourquoi le code a √©t√© √©crit de la mani√®re dont il l'a √©t√©, plut√¥t que de conna√Ætre les d√©tails techniques de son fonctionnement. En documentant le pourquoi, on peut mieux comprendre le but du code et comment il s'int√®gre dans le projet plus global.

* Privil√©gier l'auto-documentation via des nommages pertinents : le code peut √™tre plus clair et plus facile √† comprendre si les variables, les fonctions et les autres √©l√©ments ont des noms pertinents et explicites. Cela permet de documenter le code de mani√®re implicite et de rendre la lecture du code plus intuitive.

En gardant ces grands principes √† l'esprit, on peut √©crire du code qui est plus facile √† comprendre et √† maintenir, ce qui peut √©conomiser du temps et des ressources dans le long terme.

. . .

::: {.callout-tip}

Comment bien documenter un script ?

- [**Minimum**]{.orange} üö¶ : commentaire au d√©but du script pour d√©crire ce qu'il fait ;
- [**Bien**]{.orange} üëç : commenter les parties "d√©licates" du code ;
- [**Id√©al**]{.orange} üí™ : documenter ses fonctions avec la syntaxe `roxygen2`.

:::


## Pas d'ambigu√Øt√© sur les _packages_ utilis√©s

Deux fonctions peuvent avoir le m√™me nom dans des _packages_ diff√©rents. Par
exemple, la fonction `select` existe dans les _packages_ `dplyr` et `MASS`.
Par d√©faut, `R` utilise la fonction du _package_ charg√© le plus r√©cemment (avec `library()`). Ce comportement peut causer des erreurs difficiles √† rep√©rer,
car il est n√©cessaire d'ex√©cuter le code pour les d√©tecter. Par exemple, le code suivant renvoie une erreur difficile √† comprendre si on ne l'a pas d√©j√† rencontr√©e. 


```{r}
#| error: true
library(dplyr)
library(MASS)
bpe_ens_2018 <- doremifasolData::bpe_ens_2018

nombre <- bpe_ens_2018 %>%
  as_tibble() %>%
  select(TYPEQU, NB_EQUIP) 
```

Cela provient du fait que `MASS` √©tant le dernier _package_ charg√©, `R`
utilise sa fonction `select` plut√¥t que celle de `dplyr`.

Afin d'√©viter ces erreurs, il est recommand√© de r√©server
`library(pkg)` aux _packages_ dont on utilise des fonctions √† de
nombreuses reprises dans un code. Inversement, pour les _packages_ utilis√©s de fa√ßon ponctuelle il est recommand√© d'indiquer explicitement le _package_ en utilisant la notation `package::fonction()`.
De m√™me, si une fonction pr√©sente le m√™me nom dans deux packages, il est recommand√©
d'utiliser cette notation. Cela permet de garantir que la bonne fonction est appel√©e et d'√©viter les erreurs potentielles.


:::{.callout-conseil .icon}

## Le _package_ [`conflicted`](https://github.com/r-lib/conflicted#conflicted)

Le _package_ `conflicted` aide √† g√©rer les conflits de _packages_ de mani√®re fluide.
:::

## Ressources suppl√©mentaires


- [_R Packages_](https://r-pkgs.org/man.html) par Hadley Wickham and Jenny Bryan
- Une [pr√©sentation tr√®s bien faite](https://mitmat.github.io/slides/2022-05-26-egu/code-data-open-science.html#1)
- [Un cours complet](https://eliocamp.github.io/reproducibility-with-r/) sur la reproductibilit√© avec `R`
- L'√©quivalent `Python` en [3A d'ENSAE](https://ensae-reproductibilite.github.io/website/)


## Exercices

to be completed
